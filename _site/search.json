[
  {
    "objectID": "blog.html",
    "href": "blog.html",
    "title": "Riley‚Äôs Blog",
    "section": "",
    "text": "Order By\n       Default\n         \n          Date - Oldest\n        \n         \n          Date - Newest\n        \n         \n          Title\n        \n     \n  \n    \n      \n      \n    \n\n\n\n\nDate\nTitle\nReading Time\nCategories\n\n\n\n\nMar 30, 2025\nComparing Models of Delta-Notch Signalling\n12 min\nMathematics, Biology, Modelling, Python\n\n\nNov 9, 2024\nText Classification for Academic Writing\n7 min\nLLM, Python, R, Web Scraping\n\n\nOct 29, 2024\nAdvanced Obsidian for STEM Students\n15 min\nObsidian\n\n\nJul 23, 2024\nHow I Take Notes\n10 min\nObsidian\n\n\nJul 19, 2024\nFast Typesetting with Obsidian LaTeX Suite\n9 min\nObsidian\n\n\nJul 14, 2024\nHow to Study Calculus\n4 min\nUniversity\n\n\n\n\nNo matching items"
  },
  {
    "objectID": "posts/note-taking/index.html",
    "href": "posts/note-taking/index.html",
    "title": "How I Take Notes",
    "section": "",
    "text": "Every day I get bombarded with more information than I can possibly remember. From lectures to videos to random blog posts I stumble across in my spare time, I estimate that my brain alone can recall maybe 10% of what I consume. Before I started my knowledge management journey, the other 90% would slip away, only to frustrate me later. ‚ÄúI‚Äôm pretty sure I learned how to do XYZ before, but I forgot and now I have to Google it‚Äù was an all-too-common experience. This bothered me because I hate doing things twice. To keep track of everything I‚Äôd learned, I started taking a lot of notes. However, this quickly became messy, so I began developing a way to stay organized‚Äìa knowledge management system. After a year of effort, this system has grown to hundreds of notes and improved my productivity significantly.\nIn this post, I will outline exactly how and why I take notes. Obviously, what I do is tailored to my interests and needs, and it may not work for everyone. At the very least, I hope reading this gives you ideas and motivation for developing your own knowledge management system.\nPhilosophy\nAs I mentioned previously, my goal is to never have to relearn a piece of information. Every time I learn a mathematical theorem or software library, I create a brief note and jot down any important details. The information that goes into my system comes from a variety of sources, including lectures, books, blogs, podcasts, and videos. You might think that taking notes on a blog is overkill, but hear me out. Taking notes forces you to not just understand the media you‚Äôre consuming, but also summarize it.\nAccording to Bloom‚Äôs taxonomy (source), taking notes moves you from remember/understand to at least apply. If you‚Äôre being thorough, note-taking helps you deeply analyze what you‚Äôre reading and find connections with other ideas. Yes, taking notes on a piece of media probably takes 2-3 times longer than just reading it. But this is a trade-off I‚Äôm willing to make. I‚Äôd rather read one book, learn it well, and have a list of ideas to revisit later than read three books haphazardly in the same time. If I learn something useful, I write it down. It‚Äôs as simple as that.\nWhen actually taking notes, I live by the rule one idea, one note principle. In practice, this means I don‚Äôt make a note for each piece of media I consume. Instead, I add ideas from what I‚Äôm currently reading to related notes I already have. Note length isn‚Äôt important to me. Some ideas require a lot of justification or context, while others can be as short as 2-3 sentences. I do not create separate notes for examples or practice problems. Instead, I include them under an Examples or Exercises header within an existing note. I believe that if a note really represents one idea, its title should be short. If I can‚Äôt think of a concise title for a note, the note probably shouldn‚Äôt exist.\nObsidian\nI‚Äôve found digital note-taking with Obsidian to be the most effective platform for my system. I‚Äôm not going to explain how Obsidian works (there‚Äôs an excellent tutorial here), but I will outline why I use it. First, Obsidian has an extremely low barrier to entry while also being highly customizable and extensible. The plugin ecosystem for Obsidian is unmatched; it has solutions for every conceivable use case and more. Another advantage of Obsidian is that notes are stored as Markdown files, so your notes will remain accessible even if Obsidian were to be deprecated. Since notes are stored locally, Obsidian gives you complete autonomy over your data, unlike cloud-based software such as Notion and Google Drive. Finally, Obsidian lets me edit my notes using vim-like key bindings, which makes editing text so much faster. Everyone who spends a lot of time on their computer should learn vim, it‚Äôs legitimately life-changing.\nFile Structure\nThe layout of my Obsidian vault is roughly based on the Johnny Decimal system. I like this philosophy for arranging my folders because it places a hard limit on the amount of depth in my file tree. Why is depth bad? When you create a new file in Obsidian, it gets placed in the same folder as the file you currently have open. To avoid moving files around manually, it therefore makes sense to keep your file tree as shallow as possible. Additionally, the breadth of your file tree is no issue since Obsidian allows you to search your entire vault at once. You could put every single note and image into the root of your vault and Obsidian would work just fine. The issues start when you need to get all the files related to a certain topic. Then, tags or folders are necessary. In conclusion, I would recommend setting up your vault to use as few folders as possible while still maintaining some semblance of structure.\nSince my entire vault contains hundreds of notes, it can help to create maps of content (MOCs), which are notes whose sole purpose is to link to many other notes. I like to prefix my MOCs with the star (‚≠êÔ∏è) emoji, which conveniently moves them to the top of the file explorer in the sidebar. If I need nested MOCs, I‚Äôll prefix the second layer with the home (üè†) emoji, which places these notes just beneath the starred notes in the file explorer. For an example of what my file structure looks like in practice, here‚Äôs a snapshot of my ‚ÄúUniversity‚Äù folder:\nThe Fuzzy Finder\nThe Fuzzy Finder is Obsidian‚Äôs mechanism for searching a vault, which locates notes by folder and title simultaneously. Then, by pressing CMD + ENTER, I can effortlessly open the top search result in a new tab. This is extremely useful because it allows me to create, delete, and switch between notes without having to open a file explorer. Because the fuzzy finder displays the file path, it‚Äôs possible to differentiate notes by both their title and their location. Consider the following file tree:\nIf I search for MATH 100 formula sheet, the fuzzy finder will only index the file in the MATH 100 folder, which allows me to have many notes with the same title across my vault."
  },
  {
    "objectID": "posts/note-taking/index.html#plugins-and-extensions",
    "href": "posts/note-taking/index.html#plugins-and-extensions",
    "title": "How I Take Notes",
    "section": "Plugins and Extensions",
    "text": "Plugins and Extensions\nLaTeX Suite\nThe Obsidian LaTeX Suite allows me to rapidly typeset \\(\\LaTeX\\) using a set of customizable snippets. I‚Äôm not going to elaborate on this plugin‚Äôs functionality since I wrote a separate guide on it here.\nAdvanced Tables\nObsidian allows you to edit text in two ways‚Äìlive preview and source mode. Since I type a lot of \\(\\LaTeX\\) in my notes, I prefer using source mode in order to see exactly what I‚Äôm typing. Unfortunately, this means I can‚Äôt use the new Table Editor, which only works in live preview mode. To get around this problem, I use the Advanced Tables plugin, which gives me the functionality I need in source mode. Particularly, I am able to:\n\nUse TAB to cycle through cells.\nBind hotkeys to insert and delete both rows and columns.\nAutomatically align table border characters.\nAdd basic Excel-like formulas to my tables.\n\nThis plugin only works in source mode, so if you use live preview, I would just stick to the built-in table editor.\nCitations\nI‚Äôve doing research since May, and this means dealing with a lot of sources. I began using Zotero to keep track of my references, but I wanted to have access to them within my Obsidian vault. The way I added this functionality was with the Citations plugin, which automatically imports sources from a Zotero folder. Note that the Better BibTeX Zotero extension is required for this to work. The Citations plugin also allows me to create ‚Äúliterature notes‚Äù containing relevant metadata from any reference in my Zotero folder.\nUpdate (10/29/24): I am now using the Zotero Integration plugin, although Citations is perfectly fine as well.\nExcalidraw\nI do not own a drawing tablet, so it‚Äôs nice to have a way to create quick, informal diagrams. I‚Äôve found the Excalidraw plugin to work great for this use case. My favourite feature of this plugin is the ability to seamlessly import drawings into my notes without having to worry about exporting images from another piece of software.\nLinter\nThe Obsidian Linter plugin ensures that the markdown files within your vault are formatted consistently. It can do things like add a line break above and below lists, automatically capitalize headings, and remove consecutive empty lines. This normally wouldn‚Äôt matter to me but Pandoc (see below) can get picky about markdown syntax.\nPandoc\nThe Pandoc CLI application has grown to be an extremely important part of my workflow. It allows me to export markdown files from my Obsidian vault to almost any other file type. I find this to be particularly useful when typesetting mathematics since the document formatting syntax in \\(\\LaTeX\\) is just awful. I‚Äôve used Pandoc to produce research reports, assignments, and presentations using Beamer. Of course, Pandoc trades control over document formatting for writing speed. Personally, this is a sacrifice I‚Äôm willing to make. But if you need to create professional documents, exporting markdown files via Pandoc probably won‚Äôt provide enough capabilities.\nUpdate (10/29/24): Exporting markdown files to PDF proved to be too cumbersome, so I am back to using \\(\\LaTeX\\) for more formal writing.\nQuartz\nQuartz is the incredible software I use to turn my Obsidian vault into a ‚Äúmini-blog‚Äù. It seamlessly converts Obsidian-style markdown files to webpages and makes it easy to add links and attachments. My website doesn‚Äôt have all the features of a real blog, like comments and feeds. But I can quickly push new posts and easily control the layout and style of my website, which is all I need for now. If you‚Äôre interested in publishing your writing quickly and easily, I would recommend giving Quartz a try. It‚Äôs even simpler than other lightweight blogging software like Jekyll.\nUpdate (08/01/2024): I‚Äôve decided to give Obsidian Publish a try, and I‚Äôve found it to be even more straightforward than Quartz. However, Obsidian Publish does require subscription ($8 USD/month or $4.80 USD/month with the student discount).\nUpdate (10/19/2024): I‚Äôve moved the blog over to Quarto to improve support for code snippets."
  },
  {
    "objectID": "posts/note-taking/index.html#conclusion",
    "href": "posts/note-taking/index.html#conclusion",
    "title": "How I Take Notes",
    "section": "Conclusion",
    "text": "Conclusion\nMy Obsidian vault has grown to be more than just a note-taking system. I now use it to make to-do lists, create schedules, journal, and, of course, take notes. Using plugins and external software, I‚Äôve extended my Obsidian vault to the point where it‚Äôs the only software I need to produce documents of all kinds. By developing an efficient system for note-taking, I‚Äôve made it easier to process the enormous amount of information I‚Äôm exposed to every day. This has helped me learn faster, write better, and study more effectively. If you‚Äôre interested in trying something similar, the best time to start is now. All you need to do is start writing."
  },
  {
    "objectID": "posts/advanced-obsidian/index.html",
    "href": "posts/advanced-obsidian/index.html",
    "title": "Advanced Obsidian for STEM Students",
    "section": "",
    "text": "This is a follow up to my previous two posts about Obsidian, How I Take Notes and Fast Typesetting with Obsidian LaTeX Suite. Today, I take a deep dive into how I‚Äôve used Obsidian throughout my undergraduate degree to take notes in my mathematics, computer science, and statistics classes. The systems I outline in the subsequent sections are specifically tailored for university students in a STEM major, although the plugins and techniques I use are applicable to a wide variety of knowledge management use cases.\nPrerequisites: This article assumes proficiency with Obsidian and familiarity with the Obsidian LaTeX Suite plugin. Some experience with CSS may be helpful for the section on custom callouts.\nDisclaimer: If you‚Äôre just getting started with Obsidian, I‚Äôd recommend you save this post for later. Your configuration is something that should be built based on your needs and your preferences, not copied from some random person on the internet. The topics I discuss won‚Äôt be useful for everyone, and you won‚Äôt be able to determine what is relevant to you until you are more familiar with Obsidian."
  },
  {
    "objectID": "posts/advanced-obsidian/index.html#custom-callouts",
    "href": "posts/advanced-obsidian/index.html#custom-callouts",
    "title": "Advanced Obsidian for STEM Students",
    "section": "Custom Callouts",
    "text": "Custom Callouts\nA Callout is one of the ways Obsidian allows you to embed a block of content within a note. Callouts support all of the regular Obsidian features, including math mode, image embedding, and code snippets. Additionally, callouts support folding, just like headers. By default, Obsidian callouts have names like ‚ÄúNote‚Äù, ‚ÄúInfo‚Äù, ‚ÄúTodo‚Äù, and ‚ÄúTip‚Äù. These callouts come in handy occasionally, but they often aren‚Äôt the best fit for the notes I take as a STEM student. Here‚Äôs how I made callouts better.\n\n\n\nThe custom callouts I use for taking notes in my classes. Each callout is colour coded, tailored to a specific purpose, supports folding, and can be created quickly using a keyboard shortcut.\n\n\nMuch better, right? In the rest of this section, I‚Äôll provide a step-by-step explanation of how to create and use custom callouts in Obsidian. In order to create a new callout or change an existing one, you‚Äôll need to add a custom CSS file to your Obsidian vault. To do this, begin by opening your file manager and navigating to the root of your vault. Then, make sure to show hidden folders (CMD SHIFT . on MacOS). After doing this, you should see a .obsidian folder with a snippets folder inside it (if the snippets folder doesn‚Äôt exist, just create it). Then, open the snippets folder and create a file called callouts.css. In order to actually use the callouts you‚Äôre about to create, you‚Äôll need to open your Obsidian settings, navigate to the ‚ÄúAppearance‚Äù section, scroll down to ‚ÄúCSS Snippets‚Äù, and enable callouts.css.\nTo create a callout, add the following block of CSS code to callouts.css:\n.callout[data-callout=\"NAME\"] {\n    /* \n    Add CSS attributes to your callout here.\n    These can include background colours, borders,\n    padding, and anything else your heart desires!\n    */\n}\nI personally find the callout icons annoying, so I remove them for all of my callouts using the line .callout-icon {display : none;}. You can also change the styles of the .callout-title, .callout-title-inner and .callout-fold classes to further customize your callout. While doing this customization, its helpful to know that Obsidian is technically an instance of a web browser, which means you can open the developer console (CMD OPTION I on MacOS) to see which CSS classes apply to each element. Obsidian also live-reloads the stylesheets in the snippets folder, which means you can view changes to your callouts without having to restart Obsidian!\nIf you want to nerd out and customize Obsidian beyond what I discuss here, you might want to look at the complete list of CSS variables here. If you don‚Äôt want to write your own CSS, I‚Äôve included the styles for my ‚ÄúDefinition‚Äù callout, with documentation, below.\n/* These styles apply to all of my callouts */\n.callout-icon {\n    display: none; /* Remove the callout icon */\n}\n\n.callout-title {\n    padding-top: 0.5em /* Reduce the padding above the title */\n}\n\n/* These styles just apply to the \"Definition\" callout */\n.callout[data-callout=\"definition\"] {\n\n    /* Create a straight border on the left side of the callout */\n    border-radius: 0px;\n    border-left: 2px solid rgb(180, 142, 173);\n\n    /* Adjust the padding around the content */\n    padding: 5px 15px 5px 15px;\n\n    /* Set the background colour, and set opacity to 5% */\n    background-color: rgba(180, 142, 173, 0.05);\n}\n\n/* Change the colour of the inner title and fold button */\n.callout[data-callout=\"definition\"] .callout-title-inner {\n        color: rgb(180, 142, 173);\n}\n\n.callout[data-callout=\"definition\"] .callout-fold {\n        color: rgb(180, 142, 173);\n}\nNote: The colours for my callouts come from Nord, which ensures they match my Obsidian theme. I talk more about configuring Obsidian‚Äôs appearance in the final section.\nAt this point, you should be able to open Obsidian and create a new custom callout using the following markdown code. If you followed the instructions correctly, this callout should have all of the CSS attributes you specified in the previous step.\n&gt;[!NAME] Title\n&gt;Content \nThis is pretty awesome, but we can make callouts even better by using plugins to create them in just a few keystrokes. I do this by using the Obsidian LaTeX Suite plugin, which also works for general purpose text expansion. If you need a refresher on how to use this plugin, I wrote a guide on it here. As an example of how to set up a snippet for creating a custom callout, I have included the code for generating my ‚ÄúTheorem‚Äù snippet below:\n{\n    trigger: \"!thm\", \n    replacement: \"&gt;[!theorem]+ Theorem $0 ($1)\\n&gt;$2\\n&gt;\\n&gt;&lt;span style=\\\"color: rgb(235, 203, 139)\\\"&gt;&lt;b&gt;Proof&lt;/b&gt;&lt;/span&gt;. $3\", \n    options: \"tA\"\n},\nI activate this snippet by typing the trigger phrase !thm. The options tA means that this snippet activates in text mode (as opposed to math mode) and Autocompletes without me having to press TAB. In the replacement, I use $0, $1, $2, and $3 to place tabstops, which allow me to quickly jump from one location in the callout to the next. Adding \\n inserts a new line. The replacement ends up being quite long because I have to manually embed the colour of ‚ÄúProof‚Äù subheader in the snippet using a &lt;span&gt; It would be nice if there was a way to create a custom callout with additional HTML ‚Äì if anyone knows how to do this please let me know.\nThat‚Äôs all for this section. Like many of the other plugins and techniques I discuss in this post, Obsidian \\(\\LaTeX\\) Suite and custom CSS snippets are general purpose tools for improving your note taking workflows, and have tons of applications beyond what I‚Äôve shown here."
  },
  {
    "objectID": "posts/advanced-obsidian/index.html#templater-dataview",
    "href": "posts/advanced-obsidian/index.html#templater-dataview",
    "title": "Advanced Obsidian for STEM Students",
    "section": "Templater & Dataview",
    "text": "Templater & Dataview\nCustom callouts are a good party trick, but how do they fit into a bigger system? I see my callouts as the building blocks for concepts, which represent a complete idea. As an example, consider the Chain Rule as taught in a typical Calculus I course. My note on this concept consists of a definition callout, followed by a theorem callout, followed by a couple of example callouts. All of these callouts are stored in a single note, titled ‚ÄúChain Rule‚Äù. The other type of note I keep are exercises, which contain textbook questions or assignment problems that I‚Äôve solved myself. I currently have hundreds of these notes, which can make organizing them a daunting task. As my vault has grown larger, I‚Äôve actually abandoned the concept of folder-based organization entirely in favor of more organic solutions that use metadata and bidirectional linking. The Templater and Dataview plugins are essential to this workflow.\nObsidian stores metadata in an optional YAML header within each file. Within this header, you can define any number of properties in a wide variety of data formats like words, numbers, and lists. I use metadata to store the following information in my concept and exercise notes respectively:\n---\nconcept: true\ncourse: ...\nsubject: ...\ntopics: \n - ...\n - ...\n - ...\n---\n---\nexercise: true\nsource: ...\nchapter: ...\nnumber: ...\n---\nLets breakdown exactly how these YAML headers work. Adding concept: true and exercise: true make it easy to search my vault for all concepts or exercises respectively. In each concept note, I store the most recent course in which I studied the concept, which comes in handy when preparing for exams. The subject and topics fields allow me to list additional keywords which make it easier to index the note later. In each exercise note I store the source of the exercise (i.e.¬†the textbook it came from) as well as its chapter and number, if they exist.\nNow that we‚Äôve done all of this hard work adding metadata to our notes, we can reap the benefits by using the Dataview plugin to query our entire vault. I‚Äôm not going to go into detail about how to write dataview queries, since plenty of good documentation exists already. I will however give examples of some of the queries I am currently using in my vault as well as a brief description of what they do and how they work.\n1: Create a table of all notes with the subject ‚ÄúStatistics‚Äù, then sort by the time I created the note so that the newest concepts appear the top.\nTABLE join(topics, \", \") AS Topics\nWHERE concept AND subject = \"Statistics\"\nSORT file.ctime DESC\n2: Create a list of all exercises that contain a link to this concept note.\nLIST\nFROM [[]]\nWHERE exercise\nSORT source, chapter, number\n3: Create a table of all concepts from the course ‚ÄúMATH302‚Äù that were created in the last month (to study for a quiz, for example).\nTABLE join(topics, \", \") AS Topics\nWHERE concept AND course = \"MATH302\"\nWHERE file.ctime &lt;= date(today) - dur(1 month)\nThis is all lots of fun, but creating metadata can be a lot of work. The Templater plugin makes things faster by allowing us to create custom templates for the concept and exercise notes. In case you were wondering, Templater can do way more than this by allowing you to execute arbitrary Typescript code from within your vault, but we‚Äôll just focus on the templates for now. Creating templates is really simple; just define a Templates folder in the Templater settings menu and then create a new note within this folder. Within these templates you can include any amount of markdown content and YAML metadata. Additionally, you can use the variable &lt;% tp.file.cursor() %&gt; to add a tabstop. Once your happy with your templates, I would advise you to create hotkeys for importing them, which can be done from the Templater settings.\nFor your inspiration, I have included the templates for my concept and exercise notes below. I populate my concept notes with a dataview query for finding all exercises that involve this concept (see above), as well as a YAML header. Exercise notes also include a YAML header, with the source of the exercise automatically inferred from the title of the note.\n---\nconcept: true\ncourse: &lt;% tp.file.cursor(1) %&gt;\nsubject: &lt;% tp.file.cursor(2) %&gt;\ntopics: &lt;% tp.file.cursor(3) %&gt;\n---\n\n&lt;% tp.file.cursor(4) %&gt;\n\n## Exercises\n\n```dataview\nLIST\nFROM [[]]\nWHERE exercise\nSORT source, chapter, number\n```\n---\nexercise: true\nsource: &lt;% tp.file.title.split(\" \")[0] %&gt;\nchapter: &lt;% tp.file.cursor(1) %&gt;\nnumber: &lt;% tp.file.cursor(2) %&gt;\n---\n\n&lt;% tp.file.cursor(3) %&gt;\nThat‚Äôs all for this section. There is so much more to Dataview and Templater than I‚Äôve shown here. If you‚Äôre interested in integrating these plugins into your vault, I‚Äôd recommend you start by reading through their excellent documentation."
  },
  {
    "objectID": "posts/advanced-obsidian/index.html#excalidraw",
    "href": "posts/advanced-obsidian/index.html#excalidraw",
    "title": "Advanced Obsidian for STEM Students",
    "section": "Excalidraw",
    "text": "Excalidraw\nAn iPad, Apple Pencil and Goodnotes seems to be the standard way of taking notes for many of my classmates. This method has its benefits and drawbacks when compared to Obsidian. The biggest drawback is that writing text by hand is slow ‚Äì about five times slower for me, but your mileage may vary. However, Goodnotes makes it super easy to add figures, drawings, and sketches to your notes, something that vanilla Obsidian struggles with. But not all is lost. By using the Excalidraw plugin, we can create and edit figures from within Obsidian!\nBefore I continue, I think its important to mention that Excalidraw is not a general-purpose drawing program like Inkscape or MS Paint. Excalidraw is a sketching application ‚Äì it even introduces sloppiness into its lines in order to produce a hand-drawn feel. This makes Excalidraw excellent for doing quick drawings, but renders it unsuitable for creating more precise or serious images.\nThe rest of this section contains three quick tricks that have made Excalidraw more productive for me. I wish I could provide a more in-depth guide to this plugin, but I honestly don‚Äôt have the expertise to do that. If you‚Äôre interested in learning more, the author of the plugin has created hundreds of tutorials, which you can find on his YouTube channel here.\n1: By using ![[...]] you can embed an Excalidraw image directly in a note without having to export it to a .png file. By adding |100 to the inside of the hyperlink, you can resize the image to 100px (or any other size). This technique also works for images that weren‚Äôt made with Excalidraw. I also prefer images to be centered in my notes, which I accomplish using the following CSS snippet:\nimg {\n    display: block;\n    margin-left: auto;\n    margin-right: auto;\n}\n2: I use Obsidian and Excalidraw in dark mode, but sometimes I need to export my figures with a white background. To achieve this functionality, open the settings for the Excalidraw plugin, click ‚ÄúEmbedding Excalidraw into your Notes and Exporting, then‚ÄùExport Settings‚Äù, then ‚ÄúAuto-export settings‚Äù, then ‚ÄúExport both dark- and light-themed images‚Äù.\n3: I use the default hotkeys within Excalidraw in addition to some custom ones. You can find a list of active hotkeys in the ‚ÄúHotkeys‚Äù section of Obsidian‚Äôs settings. I‚Äôve created shortcuts to import \\(\\LaTeX\\) equations, create a new drawing, and import a drawing.\nI don‚Äôt add many figures and sketches to my notes, maybe 2 or 3 each week. However, when I do need to sketch something out, Excalidraw has always worked great for me. From what I can tell, the Excalidraw plugin has an insane amount of functionality. It might be just as fast as using an iPad with Goodnotes. I‚Äôd love to hear from anybody who has used this plugin for more serious use cases, so if this sounds like you, please reach out!"
  },
  {
    "objectID": "posts/advanced-obsidian/index.html#zotero-integration",
    "href": "posts/advanced-obsidian/index.html#zotero-integration",
    "title": "Advanced Obsidian for STEM Students",
    "section": "Zotero Integration",
    "text": "Zotero Integration\nZotero Integration is a handy plugin for importing information from a Zotero library into an Obsidian vault. It also allows you to import PDF annotations from Zotero into Obsidian, a feature I don‚Äôt use myself. I primarily use Zotero integration for the literature notes feature, which allows me to create a note in Obsidian which contains information about an academic paper. This information is stored in the metadata and can include details such as the title, authors, year, abstract, and DOI. I use links to literature notes as an ‚Äúin-text citation‚Äù system within my vault that gives me easy access to the papers I‚Äôm thinking about.\nTo get this system set up, add a new template to Zotero Integration titled ‚ÄúLiterature Note‚Äù. I set the output path to Literature Notes/{{citekey}}.md which gives each literature note a name based on its Zotero citekey and moves it to the Literature Notes folder. Then, create a template file (I called mine literature-note) and specify it in the Zotero Integration settings. Here‚Äôs my template file:\n---\nyear: {{date | format(\"YYYY\")}}\ntags: {% if allTags %}{{allTags}}{% endif %}\nDOI: {{DOI}}\nauthors: {{authors}}\nurl: {{url}}\nbibliography: {{bibliography}}\n---\n\n**{{title}}**\n\n{{pdfZoteroLink}}\n\n# Notes\n\n{% persist \"notes\" %}\n\n{% endpersist %}\nThis template automatically includes the year, tags, DOI, authors, URL, and bibliography in the metadata. The {% persist \"notes\" %} and {% endpersist %} delimiters are essential to prevent the content of the literature notes from being deleted if the same paper is imported again. To actually create a new literature note, use the command Zotero Integration: Import notes from the command palette, or bind a hotkey in your Obsidian settings.\nLimitations: Using the Zotero Integration plugin tempted me to try to turn Obsidian into a fully-fledged environment for writing an academic paper, replete with support for citations, exporting via Pandoc, and various environments for handling figures. I got close but I ultimately couldn‚Äôt get things to work as well as native \\(\\LaTeX\\), which I edit using Neovim."
  },
  {
    "objectID": "posts/advanced-obsidian/index.html#bonus-minimalist-obsidian",
    "href": "posts/advanced-obsidian/index.html#bonus-minimalist-obsidian",
    "title": "Advanced Obsidian for STEM Students",
    "section": "Bonus: Minimalist Obsidian",
    "text": "Bonus: Minimalist Obsidian\nThis section is all about my personal preferences for making Obsidian look pretty. In general, I believe in keeping my Obsidian as minimalist as possible. I‚Äôm serious about this. When I first open Obsidian, here‚Äôs what I see:\n\nThe easiest way to remove all the unnecessary buttons, toggles, and icons is to use the Hider plugin. Any elements that aren‚Äôt included in this plugin can be hidden using a CSS snippet (see the section on custom callouts). The theme I use is Nord Dark from Anupuccin, with some additional changes to the typography. I personally find the default headers in Obsidian to be unreasonably large, so I use the Style Settings plugin to make them smaller. I also prefer serif fonts (they‚Äôre easier on the eyes), so I replaced the default font SF Display with Palatino, which I think is quite beautiful. There‚Äôs definitely some more little things I‚Äôve done over the years to improve Obsidian‚Äôs appearance, but these are the ones I can remember off the top of my head."
  },
  {
    "objectID": "posts/advanced-obsidian/index.html#conclusion",
    "href": "posts/advanced-obsidian/index.html#conclusion",
    "title": "Advanced Obsidian for STEM Students",
    "section": "Conclusion",
    "text": "Conclusion\nCustomizing your vault with CSS snippets, plugins, and various other shenanigans can be both exciting and rewarding. I‚Äôve probably spent upwards of 20 hours fine-tuning my Obsidian setup to be practical, fast, and most importantly, fun. While a lot of people say that configuring software like Obsidian and Neovim is a waste of time, I say that if you‚Äôre going spend your life learning and building, you might as well do it in an environment that is pleasant for you. Thanks for reading."
  },
  {
    "objectID": "posts/fast-typesetting/index.html",
    "href": "posts/fast-typesetting/index.html",
    "title": "Fast Typesetting with Obsidian LaTeX Suite",
    "section": "",
    "text": "If you‚Äôve ever prepared a document with \\(\\LaTeX\\) before, you know that it can be a long and frustrating process. The language is built to create scientific papers, and it comes equipped to deal with the precise formatting that one would expect from such publications. But the cost of precision is time, and virtually nothing in \\(\\LaTeX\\) is designed to be done quickly. Every command requires the inconveniently located backslash key, and you‚Äôll probably get carpal tunnel from opening and closing the dreaded curly brackets every five keystrokes. To make matters worse, common mathematical symbols are often unreasonably verbose, like \\partial, \\mathbb{R}, or \\leftrightarrow.\nHowever, not all is lost. This article will show you how to transform \\(\\LaTeX\\) from a monolith of confusing commands to a simple, customizable tool for taking notes in math and science classes. To do this, I will be using the personal knowledge management software Obsidian. Using this technique, I have taught myself to typeset mathematics faster than I can write. I have produced hundreds of typeset notes that look like the image below during class. By using pandoc to export my markdown files to PDF, I have also made typesetting written assignments significantly faster. If any of this sounds interesting to you, keep reading. I promise this is useful stuff.\n\n\n\n\nA note about Euclidian Spaces from my first course in linear algebra. The key to making notes like is the use of \\(\\LaTeX\\) snippets for fast typesetting, which I explain how to use in the rest of this post.\n\n\nThe Solution\nIn 2019, the late Gilles Castel published an excellent blog post about taking notes using \\(\\LaTeX\\) and Vim. Instead of typing the commands by hand, he used a snippet program to autocomplete them as he typed. If you‚Äôre familiar with configuring Vim and want to try this, the original article is here. A more detailed guide, written by Elijian Mastnak, can be found here.\nHowever, learning Vim and managing a bunch of dotfiles can be exhausting. For the less technically inclined, there‚Äôs the Obsidian LaTeX Suite, which provides snippet functionality within Obsidian. It can be installed using the following steps:\n\nOpen the settings menu in Obsidian\nGo to the community plugins tab and make sure that ‚ÄúRestricted Mode‚Äù is off.\nClick ‚ÄúBrowse‚Äù, then search for, install, and enable the Obsidian \\(\\LaTeX\\) Suite.\n\nTo check that it was installed correctly, open a new note and type mk. If the text is automatically replaced with $$, then the plugin is working.\nWriting Snippets\nFor a more thorough introduction to writing snippets, I recommend you read the documentation. To create and remove snippets, open the Obsidian settings menu, then click on the ‚Äú\\(\\LaTeX\\) Suite‚Äù tab under ‚ÄúCommunity Plugins‚Äù. In this, tab you should see a list of snippets that looks like this:\n{trigger: \"...\", replacement: \"...\", options: \"...\"}\ntrigger is the series of keystrokes that will activate the snippet. The snippets are smart‚Äìautocomplete will replace the longest active snippet. As an example, suppose you had two snippets with triggers psb and sb. If you were to type in psb, the autocomplete will recognize this as the first snippet and replace it properly, ignoring the fact that the sb snippet is also defined. This is useful because it allows for some overlap in your snippets. But be careful, if the two snippets were sb and sbp, the second snippet would never activate.\nreplacement is the text that will be substituted in place of the trigger. If you‚Äôre writing \\(\\LaTeX\\), remember to escape backslashes by writing \\\\ instead of \\. You can also add a line break with \\n. The replacement can contain any number of tab stops, which are included using the characters $0, $1, etc. Upon snippet activation, the cursor will be moved to the first tab stop.\noptions is a string of characters that contains the settings:\n\nm stands for ‚Äúmath mode‚Äù. If this setting is enabled, the snippet will only activate in math mode (both inline and display).\nA stands for ‚Äúautocomplete‚Äù. If this setting is enabled, the trigger will be replaced immediately. Otherwise, you will have to press TAB in order to activate the snippet.\n\nAs an example, here is a simple snippet that replaces ff with \\frac command:\n{\n    trigger: \"ff\",\n    replacement: \"\\\\frac{$0}{$1}\",\n    options: \"mA\"\n}\n\nNote that we use escape the backslash character using \\\\.\nUpon snippet activation, the cursor will move to the $0 tab stop. If you press tab again, it will move to the $1 tab stop.\n\"mA\" means the snippet will activate automatically in math mode.\n\nBuilding a System\nNow, go to back to the settings menu, and delete all the default snippets. If you want to remember your snippets and build a system that works for you, I would highly recommend writing them yourself. Of course, feel free to check the default snippets for ideas, many of them are very good. Here is some general advice on writing snippets:\n\nEvery snippet should autocomplete using the \"A\" option.\nSnippets should be 2 or 3 characters long, 4 at the most.\nSnippets should not use groups of letters that are commonly used in mathematical expressions. For example, an autocompleting snippet with the trigger dx will frequently activate when you don‚Äôt want it to.\nUse capital letters and special characters to differentiate snippets. That being said, you should try to keep your snippets as fast as possible. Using inaccessible keys like | or ~ in your snippets will slow you down.\nOnly create snippets when you need them. Remember that every additional snippet creates more possibilities for errors.\n\nMy Snippets\nAs I mentioned above, I highly recommend creating your own snippets. That being said, I will begrudgingly share what I‚Äôve been using below to you get started.\nEnvironments:\n{\n    trigger: \"cases\", \n    replacement: \"\\\\begin{cases}\\n$0\\n\\\\end{cases}\", \n    options: \"mA\"\n},\n{\n    trigger: \"align\", \n    replacement: \"\\\\begin{align}\\n$0\\n\\\\end{align}\", \n    options:\"mA\"\n},\n{\n    trigger: \"eqn\", \n    replacement: \"\\\\begin{equation}\\n$0\\n\\tag{$1}\\\\end{equation}\", \n    options: \"mA\"\n}\nTrigonometric Functions:\n{trigger: \"sin\", replacement: \"\\\\sin \", options: \"mA\"},\n{trigger: \"cos\", replacement: \"\\\\cos \", options: \"mA\"},\n{trigger: \"tan\", replacement: \"\\\\tan \", options: \"mA\"},\n{trigger: \"hsin\", replacement: \"\\\\sinh \", options: \"mA\"},\n{trigger: \"hcos\", replacement: \"\\\\cosh \", options: \"mA\"},\n{trigger: \"htan\", replacement: \"\\\\tanh \", options: \"mA\"},\n{trigger: \"asin\", replacement: \"\\\\arcsin \", options: \"mA\"},\n{trigger: \"acos\", replacement: \"\\\\arccos \", options: \"mA\"},\n{trigger: \"atan\", replacement: \"\\\\arctan \", options: \"mA\"},\nBrackets:\n{trigger: \"‚Ä¶\", replacement: \"\\\\dots\", options: \"mA\"},\n{trigger: \"_\", replacement: \"_{$0}$1\", options: \"mA\"},\n{trigger: \"(\", replacement: \"($0)$1\", options: \"mA\"},\n{trigger: \"[\", replacement: \"[$0]$1\", options: \"mA\"},\n{trigger: \"|\", replacement: \"|$0|$1\", options: \"mA\"},\n{trigger: \"lr(\", replacement: \"\\\\left( $0 \\\\right) $1\", options: \"mA\"},\n{trigger: \"lr[\", replacement: \"\\\\left[ $0 \\\\right] $1\", options: \"mA\"},\n{trigger: \"lr|\", replacement: \"\\\\left| $0 \\\\right| $1\", options: \"mA\"},\n{trigger: \"ang\", replacement: \"\\\\langle $0 \\\\rangle $1\", options: \"mA\"},\n{trigger: \"set\", replacement: \"\\\\{ $0 \\\\} $1\", options: \"mA\"},\nGreek Letters:\n{trigger: \";a\", replacement: \"\\\\alpha \", options: \"mA\"},\n{trigger: \";b\", replacement: \"\\\\beta \", options: \"mA\"},\n{trigger: \"chi\", replacement: \"\\\\chi \", options: \"mA\"},\n{trigger: \";g\", replacement: \"\\\\gamma \", options: \"mA\"},\n{trigger: \";G\", replacement: \"\\\\Gamma \", options: \"mA\"},\n{trigger: \";d\", replacement: \"\\\\delta \", options: \"mA\"},\n{trigger: \";D\", replacement: \"\\\\Delta \", options: \"mA\"},\n{trigger: \";e\", replacement: \"\\\\epsilon \", options: \"mA\"},\n{trigger: \";z\", replacement: \"\\\\zeta \", options: \"mA\"},\n{trigger: \";t\", replacement: \"\\\\theta \", options: \"mA\"},\n{trigger: \";T\", replacement: \"\\\\Theta \", options: \"mA\"},\n{trigger: \";k\", replacement: \"\\\\kappa \", options: \"mA\"},\n{trigger: \";l\", replacement: \"\\\\lambda \", options: \"mA\"},\n{trigger: \";L\", replacement: \"\\\\Lambda \", options: \"mA\"},\n{trigger: \"nu\", replacement: \"\\\\nu\", options: \"mA\"},\n{trigger: \"mu\", replacement: \"\\\\mu \", options: \"mA\"},\n{trigger: \"rho\", replacement: \"\\\\rho \", options: \"mA\"},\n{trigger: \";s\", replacement: \"\\\\sigma \", options: \"mA\"},\n{trigger: \";S\", replacement: \"\\\\Sigma \", options: \"mA\"},\n{trigger: \";o\", replacement: \"\\\\omega \", options: \"mA\"},\n{trigger: \";O\", replacement: \"\\\\Omega \", options: \"mA\"},\n{trigger: \"pi\", replacement: \"\\\\pi \", options: \"mA\"},\n{trigger: \"Pi\", replacement: \"\\\\Pi \", options: \"mA\"},\n{trigger: \"phi\", replacement: \"\\\\phi \", options: \"mA\"},\n{trigger: \"Phi\", replacement: \"\\\\Phi \", options: \"mA\"},\n{trigger: \"psi\", replacement: \"\\\\psi \", options: \"mA\"},\n{trigger: \"Psi\", replacement: \"\\\\Psi \", options: \"mA\"},\n{trigger: \"tau\", replacement: \"\\\\tau \", options: \"mA\"},\n{trigger: \"xi\", replacement: \"\\\\xi\", options: \"mA\"},\nPrecalculus:\n{trigger: \"sr\", replacement: \"^{2}\", options: \"mA\"},\n{trigger: \"cb\", replacement: \"^{3}\", options: \"mA\"},\n{trigger: \"rd\", replacement: \"^{ $0 }$1\", options: \"mA\"},\n{trigger: \"sq\", replacement: \"\\\\sqrt{ $0 }$1\", options: \"mA\"},\n{trigger: \"ee\", replacement: \"e^{ $0 }$1\", options: \"mA\"},\n{trigger: \"ep\", replacement: \"\\\\exp\", options: \"mA\"},\n{trigger: \"ff\", replacement: \"\\\\frac{ $0 }{ $1 }$2\", options: \"mA\"},\n{trigger: \"pm\", replacement: \"\\\\pm\", options: \"mA\"},\n{trigger: \"oo\", replacement: \"\\\\infty\", options: \"mA\"},\n{trigger: \"neq\", replacement: \"\\\\neq\", options: \"mA\"},\n{trigger: \"geq\", replacement: \"\\\\geq\", options: \"mA\"},\n{trigger: \"leq\", replacement: \"\\\\leq\", options: \"mA\"},\n{trigger: \"ln\", replacement: \"\\\\ln\", options: \"mA\"},\n{trigger: \"log\", replacement: \"\\\\log\", options: \"mA\"},\nLinear Algebra:\n{trigger: \"tm\", replacement: \"\\\\times\", options: \"mA\"},\n{trigger: \"dot\", replacement: \"\\\\cdot\", options: \"mA\"},\n{trigger: \"vec\", replacement: \"\\\\mathbf{$0}$1\", options: \"mA\"},\n{trigger: \"perp\", replacement: \"\\\\perp\", options: \"mA\"},\n{trigger: \"para\", replacement: \"\\\\parallel\", options: \"mA\"},\n{trigger: \"nrm\", replacement: \"\\\\left\\\\lVert $0 \\\\right\\\\rVert $1\", options: \"mA\"},\n{trigger: \":i\", replacement: \"\\\\mathbf{i}\", options: \"mA\"},\n{trigger: \":j\", replacement: \"\\\\mathbf{j}\", options: \"mA\"},\n{trigger: \":k\", replacement: \"\\\\mathbf{k}\", options: \"mA\"},\n{trigger: \"hat\", replacement: \"\\\\hat{$0}$1\", options: \"mA\"},\n{\n    trigger: \"vmtx\", \n    replacement: \"\\\\begin{vmatrix}\\n$0\\n\\\\end{vmatrix}\", \n    options: \"mA\"\n},\n{\n    trigger: \"mtx\", \n    replacement:\n    \"\\\\begin{pmatrix}\\n$0\\n\\\\end{pmatrix}\",\n    options: \"mA\"\n},\n{\n    trigger: \"aug\", \n    replacement: \"\\\\left[\\\\begin{array{$0|c}\\n$1\\n\\\\end{array}\\\\right]\", \n    options: \"mA\"\n},\nCalculus:\n{trigger: \"sum\", replacement: \"\\\\sum\", options: \"mA\"},\n{trigger: \"lim\", replacement: \"\\\\lim_{$0 \\\\to $1}$2\", options: \"mA\"},\n{trigger: \"par\", replacement: \"\\\\frac{\\\\partial $0}{\\\\partial $1}$2\", options: \"mA\"},\n{trigger: \"int\", replacement: \"\\\\int $0 \\\\, d$1\", options: \"mA\"},\n{trigger: \"oint\", replacement: \"\\\\oint $0 \\\\, d$1\", options: \"mA\"},\n{trigger: \"iint\", replacement: \"\\\\iint\", options: \"mA\"},\n{trigger: \"iiint\", replacement: \"\\\\iiint\", options: \"mA\"},\n{trigger: \"@\", replacement: \"\\\\Bigg|_{$0}^{$1}\", options: \"mA\"},\n{trigger: \"nb\", replacement: \"\\\\nabla\", options: \"mA\"},\n{trigger: \"LL\", replacement: \"\\\\mathcal{L}\", options: \"mA\"},\n{trigger: \"hess\", replacement: \"\\\\mathscr{H}\", options: \"mA\"},\nLogic and Set Theory:\n{trigger: \"and\", replacement: \"\\\\land\", options: \"mA\"},\n{trigger: \"orr\", replacement: \"\\\\lor\", options: \"mA\"},\n{trigger: \"not\", replacement: \"\\\\lnot\", options: \"mA\"},\n{trigger: \"iff\", replacement: \"\\\\leftrightarrow\", options: \"mA\"},\n{trigger: \"-&gt;\", replacement: \"\\\\rightarrow\", options: \"mA\"},\n{trigger: \"mod\", replacement: \"\\\\bmod\", options: \"mA\"},\n{trigger: \"==\", replacement: \"\\\\equiv\", options: \"mA\"},\n{trigger: \"cmp\", replacement: \"\\\\circ\", options: \"mA\"},\n{trigger: \"tf\", replacement: \"\\\\therefore\", options: \"mA\"},\n{trigger: \"apx\", replacement: \"\\\\approx\", options: \"mA\"},\n{trigger: \"fa\", replacement: \"\\\\forall\", options: \"mA\"},\n{trigger: \"ex\", replacement: \"\\\\exists\", options: \"mA\"},\n{trigger: \"nex\", replacement: \"\\\\nexists\", options: \"mA\"},\n{trigger: \"inn\", replacement: \"\\\\in\", options: \"mA\"},\n{trigger: \"nin\", replacement: \"\\\\notin\", options: \"mA\"},\n{trigger: \"psb\", replacement: \"\\\\subset\", options: \"mA\"},\n{trigger: \"nsb\", replacement: \"\\\\not\\\\subset\", options: \"mA\"},\n{trigger: \"sb\", replacement: \"\\\\subseteq\", options: \"mA\"},\n{trigger: \"stu\", replacement: \"\\\\cup\", options: \"mA\"},\n{trigger: \"sti\", replacement: \"\\\\cap\", options: \"mA\"},\n{trigger: \"bsu\", replacement: \"\\\\bigcup\", options: \"mA\"},\n{trigger: \"bsi\", replacement: \"\\\\bigcap\", options: \"mA\"},\n{trigger: \"prd\", replacement: \"\\\\prod\", options: \"mA\"},\n{trigger: \"std\", replacement: \"\\\\setminus\", options: \"mA\"},\n{trigger: \"stc\", replacement: \"^{\\\\complement}\", options: \"mA\"},\n{trigger: \"ets\", replacement: \"\\\\emptyset\", options: \"mA\"},\n{trigger: \"=&gt;\", replacement: \"\\\\Rightarrow\", options: \"mA\"},\n{trigger: \"&lt;=&gt;\", replacement: \"\\\\Leftrightarrow\", options: \"mA\"},\n{trigger: \"bar\", replacement: \"\\\\overline{$0}$1\", options: \"mA\"},\n{trigger: \"qed\", replacement: \"\\\\blacksquare\", options: \"mA\"},\nNumber Systems:\n{trigger: \"CC\", replacement: \"\\\\mathbb{C}\", options: \"mA\"},\n{trigger: \"RR\", replacement: \"\\\\mathbb{R}\", options: \"mA\"},\n{trigger: \"ZZ\", replacement: \"\\\\mathbb{Z}\", options: \"mA\"},\n{trigger: \"NN\", replacement: \"\\\\mathbb{N}\", options: \"mA\"},\n{trigger: \"QQ\", replacement: \"\\\\mathbb{Q}\", options: \"mA\"},\n{trigger: \"FF\", replacement: \"\\\\mathbb{F}\", options: \"mA\"},"
  },
  {
    "objectID": "posts/sentence-analysis/index.html",
    "href": "posts/sentence-analysis/index.html",
    "title": "Text Classification for Academic Writing",
    "section": "",
    "text": "Academic journals require research articles to follow a specific format. First, a 150-300 word abstract provides a big-picture overview of the main ideas contained within the paper. Following the abstract is a longer introduction. This section serves multiple purposes, including explaining the motivations behind the research, summarizing past results in the field, identifying key gaps in the literature, and providing an overview of key methods and results. After the introduction, most research articles have dedicated methods, results, discussion, and conclusion sections. However, these sections are often renamed, split up, or removed entirely to better suit the paper.\nSince the abstract and introduction are central to all journal articles, understanding how to write these sections effectively is an essential skill for researchers. However, advice on paper writing is often general and unclear. While recommendations like ‚Äústart broad and then gradually get narrower‚Äù or ‚Äúmake sure to emphasize the importance of your research‚Äù aren‚Äôt bad advice, there‚Äôs much more nuance in an excellent paper. Today, I outline a data-driven framework for writing abstracts and introductions for research articles. To do this, I analyzed 500 papers from the PLOS Computational Biology journal using the open source LLM Llama 3.2."
  },
  {
    "objectID": "posts/sentence-analysis/index.html#web-scraping",
    "href": "posts/sentence-analysis/index.html#web-scraping",
    "title": "Text Classification for Academic Writing",
    "section": "Web Scraping",
    "text": "Web Scraping\nThis project required abstracts and introductions from many academic papers. Getting a bunch of abstracts is straightforward, the arXiv Dataset contains millions of them. However, sourcing the introductions from these papers is much harder. My first idea was to feed the full-text PDFs from the arXiv dataset directly into the LLM. However, even state-of-the-art models like ChatGPT 4o struggled to differentiate between the various sections in the research articles. I‚Äôm not entirely sure why this task is so difficult, but I think it might have something to do with the two-column formatting in many academic journals or the weird placement of figures throughout the text. I needed a better solution.\nLuckily, most journals publish research articles on the internet in a relatively consistent format. This makes it possible to build a web scraper to automatically extract papers from the publisher‚Äôs website. But web scraping is a tedious and annoying task. Small changes between web pages can completely break your scraper, and you‚Äôre constantly running the risk of getting your IP permanently banned for making too many requests. Many journals have their articles locked behind paywalls, which adds a layer of complexity I wasn‚Äôt equipped to deal with. To keep things as simple as possible, I extracted papers from a single open-source journal1, PLOS Computational Biology. To build the web scraper, I used the Python library beautifulsoup4. After six hours of scraping, I managed to wrangle all 9,653 abstracts and introductions from PLOS Computational Biology into a .json file. Now I was ready to categorize."
  },
  {
    "objectID": "posts/sentence-analysis/index.html#sentence-categorization",
    "href": "posts/sentence-analysis/index.html#sentence-categorization",
    "title": "Text Classification for Academic Writing",
    "section": "Sentence Categorization",
    "text": "Sentence Categorization\nAfter gathering the data, I ran each abstract and introduction through the Llama 3.2 90B text-preview model to categorize the sentences. I was hoping to use the 1B and 3B models which are small enough to run on my laptop, but unfortunately, they weren‚Äôt giving me accurate results. Since I don‚Äôt own a massive stack of GPUs, I used Groq to run the categorization job in the cloud. With their free plan, I got access to 500,000 tokens of chat completions per day. This was enough to categorize the abstracts and introductions from about 150 papers each night2. Since doing all 9,653 papers would have taken months, I opted to analyze the 500 most recent papers instead. This was still a big job. In total, the LLM analyzed over 20,000 sentences with over 300,000 words. The prompt I used is shown below:\n\nHere are four categories for classifying the sentences of a scientific paper. Make sure that you correctly divide the text into sentences. Remember that abbreviations like ‚Äúet al.‚Äù do not constitute the end of a sentence. However, all sentences must end with a period or question mark.\nCATEGORY 1: Motivation for the research in a broad context. This type of sentence helps the reader to understand why the research is relevant, useful, and interesting.\nCATEGORY 2: Past research in the field, which may be experimental or theoretical. Sentences in this category may also describe the results of previous research efforts.\nCATEGORY 3: Descriptions of topics that remain poorly understood or descriptions of gaps in the literature that need to be filled.\nCATEGORY 4: The methods used by the authors in this research paper. Sentences in this category may also discuss the results of this research paper.\nA sentence can only belong to one category. Use the context of the paragraph to determine whether a sentence is discussing the research paper itself or a previous study. Your response should be a JSON object in the following format:\n{\n \"abstract\": [\n   {\n     \"sentence\": ...,\n     \"position\": ...,\n     \"category\": ...,\n   },\n   ...\n ],\n \"introduction\": [\n   {\n     \"sentence\": ...,\n     \"position\": ...,\n     \"category\": ...,\n   },\n   ...\n ]\n}\nThe ‚Äúsentence‚Äù field must contain the exact sentence that was classified. The ‚Äúposition‚Äù is the relative position of the sentence in the text (i.e.¬†1 for the first sentence, 2 for the second sentence, etc.). The ‚Äúcategory‚Äù should be 1, 2, 3, or 4. Now, I will provide you with an abstract followed by an introduction. Classify each of the sentences. Ensure that the first object in the ‚Äúabstract‚Äù and ‚Äúintroduction‚Äù fields have a position of 1."
  },
  {
    "objectID": "posts/sentence-analysis/index.html#results",
    "href": "posts/sentence-analysis/index.html#results",
    "title": "Text Classification for Academic Writing",
    "section": "Results",
    "text": "Results\n\n\n\nFigure 1: Smoothed frequency of each sentence category plotted against relative position in the abstract/introduction. Precisely, a sentence at position \\(m\\) in a section with \\(n\\) sentences has a relative position of \\(m/n\\). On average, the categories are arranged in order. Categories 2 (background) and 3 (research gaps) overlap significantly. This suggests that many authors are interweaving past results from the literature with areas for further study.\n\n\n\n\n\nFigure 2: Boxplot of the number of sentences in each section and category. On average, abstracts have two sentences of motivation, two sentences of background, and one sentence explaining a research gap. However, most of the abstract is dedicated to summarizing the methods and results from the paper. In the introduction, authors only include a few sentences about motivation and research gaps. The majority of the introduction is dedicated to explaining background information, with some room for summarizing the methods and results.\n\n\n\n\n\nFigure 3: Boxplot of the total number of sentences in the abstract and introduction. The median abstract contains 9 sentences, with most abstracts containing between 6-11 sentences. The vast majority of abstracts are between 150 and 300 words. Introductions tend to have around 35 sentences, although some are significantly longer. Most introductions have about 1,000 words."
  },
  {
    "objectID": "posts/sentence-analysis/index.html#conclusions",
    "href": "posts/sentence-analysis/index.html#conclusions",
    "title": "Text Classification for Academic Writing",
    "section": "Conclusions",
    "text": "Conclusions\nA standard abstract in PLOS Computational Biology has two sentences of motivation, followed by 2-3 sentences explaining background information and the research gap the authors intend to fill. The rest of the abstract summarizes the methods and results used in the paper. A standard introduction contains a few sentences of motivation, followed by 20-30 sentences (3-4 paragraphs) explaining relevant background information and discussing the research gaps. This is followed by 4-5 sentences (1 paragraph) summarizing the paper‚Äôs methods and results3.\nI suspect that the structure of academic papers varies between disciplines, so I‚Äôm not sure how generalizable these results are. However, you can find all the code I used on my Github if you would like to try this on a different journal. I also included the abstracts and introductions (~9,000 entries) and the categorized sentences from the 500 papers I analyzed (~20,000 entries) if you‚Äôd like to see the data for yourself. Thanks for reading!"
  },
  {
    "objectID": "posts/sentence-analysis/index.html#acknowledgment",
    "href": "posts/sentence-analysis/index.html#acknowledgment",
    "title": "Text Classification for Academic Writing",
    "section": "Acknowledgment",
    "text": "Acknowledgment\nI would like to thank Prof.¬†Eric Cytrynbaum for providing the idea for this project."
  },
  {
    "objectID": "posts/sentence-analysis/index.html#footnotes",
    "href": "posts/sentence-analysis/index.html#footnotes",
    "title": "Text Classification for Academic Writing",
    "section": "Footnotes",
    "text": "Footnotes\n\n\nI picked computational biology over another PLOS journal because its closest to my own research interests. Hopefully, the results of this analysis will come in handy if I ever manage to write a paper!‚Ü©Ô∏é\nWhile I was running my classification jobs through Groq, I stumbled across the hilariously named and immensely practical caffeinate command, which allows you to prevent your computer from sleeping until a specified process completes.‚Ü©Ô∏é\nFor the data anlysis component of this project I tried using the tidyverse for the first time, and it was great! The entire data processing pipeline is just so idiomatic and simple. And ggplot2 definitely outshines both matplotlib and plotly. It doesn‚Äôt seem like R is very fast or scaleable, but I‚Äôll definitely be using it for EDA and plotting from now on.‚Ü©Ô∏é"
  },
  {
    "objectID": "posts/study-calculus/index.html",
    "href": "posts/study-calculus/index.html",
    "title": "How to Study Calculus",
    "section": "",
    "text": "As of October 2024, I‚Äôve been a TA for five first-year calculus courses at UBC. Students often ask me, ‚ÄúHow do I succeed in this class?‚Äù or more frequently, ‚ÄúHow do I pass this class?‚Äù Here‚Äôs my advice.\n1: Make a Spreadsheet\nKeep a list of questions you struggled with and write down what you learned from them. I use a spreadsheet that looks like this:\n\n\n\nQuestion\nConcept\nNotes\n\n\n\n\nWW00, Q1\nFTC\nUse the chain rule to differentiate.\n\n\n‚Ä¶\n‚Ä¶\n‚Ä¶\n\n\n\nColor-code the questions: green if you understand everything, yellow if you‚Äôre a little confused, or red if you‚Äôre completely lost. Include only the questions you get wrong. This technique is a lifesaver during exam season, providing a personalized list of challenging questions for you to study from. Additionally, reading through the ‚ÄúNotes‚Äù column before an exam helps recall the techniques you‚Äôve learned throughout the course.\n2: Don‚Äôt Forget the Basics\nWith the fast pace of math courses, its easy to assume that you don‚Äôt have time to review previous material. But I think this is a terrible mindset. Calculus exams are unforgiving, and you will do poorly if you don‚Äôt have a solid understanding of precalculus. I highly encourage everyone who thinks they have gaps in their foundational knowledge to review the following topics:\n\nExponent laws\nLogarithm rules\nFinding intercepts and asymptotes\nFunction composition and inverse functions\nTrigonometric functions and the unit circle\n\nIt shouldn‚Äôt take you more than a couple hours to go over these concepts, and doing so and it will make the rest of your semester so much easier.\n3: Put the Calculator Away\nIf you came from the Canadian high school system, you were probably allowed a calculator for your precalculus classes. However, calculators are not allowed in the first-year calculus courses at UBC (and most upper-year math courses). Some students live in denial of this policy and continue using a calculator whenever possible throughout the semester. Unsurprisingly, these people later lose marks on exams due to computation errors. To minimize the chances of these silly mistakes, I think its best to avoid using a calculator while doing practice problems. Mental math isn‚Äôt fun, but it is necessary for success in calculus. One exception to this rule is the written assignments in MATH 100/101, which often require laborious calculations. You should still try to solve these problems with pencil and paper, but definitely check your answers with a calculator.\n4: Embrace the Struggle\nIf you don‚Äôt have an exam soon, it‚Äôs okay to struggle with practice questions. You often learn more this way than by asking a friend or going to office hours. Trying new ideas and getting things wrong deepens your understanding of the material. When you finally get the right answer, you‚Äôll understand not just how to solve the problem, but why the solution works. Spending an hour on a difficult problem can be more productive than doing ten easier problems in the same period. Of course, if you‚Äôve exhausted every idea you have, it‚Äôs time to get help.\n5: Practice Being Fast\nIf you have an exam soon, you should practice doing problems quickly. I‚Äôve found that math exams have more restrictive time limits than exams in other departments, especially on midterms. The all-too-common experience of ‚ÄúI remembered how to solve the problem after the test!‚Äù is ultimately a problem of being too slow. Find out how long the test is, find out how many questions there are, and ensure you can work fast enough.\nWhen taking the test, tackle the easiest problems first. If you‚Äôre well-prepared, you‚Äôll get through these quickly, leaving you with more time for the harder problems. On final exams, I like to take a bathroom break at the halfway point‚Äîit helps me refocus. When checking your work, try doing the problems in reverse. For example, if a question asks you to evaluate an integral, check that the derivative of your answer is the original function. It isn‚Äôt always straightforward, but try to have a mindset of verifying rather than redoing.\nConclusion\nFirst-year calculus courses at UBC are challenging for everyone, even math majors. I know someone who has taken over fifteen math courses at UBC and still says the MATH 101 final was the hardest exam they‚Äôve ever written. Luckily, there are many resources available for students. Sign up for Piazza, go to office hours, and discuss the material with your friends. Success in these classes is not impossible‚Äîthousands of students score above 80% in MATH 1XX every year. I believe that you can be one of them. Good luck!"
  },
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "Riley Wheadon",
    "section": "",
    "text": "Hi there! I‚Äôm Riley, a third year undergraduate student pursuing a mathematics degree at the University of British Columbia. In addition to my studies, I‚Äôm interested in running, philosophy, Unix, Vim, and building efficient systems for thinking and writing. I also have a blog where I write about note-taking methods, study strategies and my projects.\nI recently finished two semesters of research with Dr.¬†Eric Cytrynbaum where we developed a mathematical model of root growth in A. Thaliana. An up-to-date copy of the draft can be found here and the code for the project can be found here.\nMy email is rileywheadon@gmail.com. Please don‚Äôt be afraid to reach out! All opinions are my own and are not representative of any groups I may be affiliated with."
  },
  {
    "objectID": "posts/delta-notch/index.html",
    "href": "posts/delta-notch/index.html",
    "title": "Comparing Models of Delta-Notch Signalling",
    "section": "",
    "text": "Mathematical biology is a field of study that uses mathematical models to better understand the natural world. Oftentimes, these models involve simulating the behaviour of individual molecules, cells, or organisms (agents). While highly accurate, these agent-based models can be computationally expensive. Therefore, when the number of agents becomes large, it becomes impractical to track each one individually. Instead, mathematicians use ordinary differential equations (ODEs) to describe the collective behaviour of the entire population. In this post, we‚Äôll learn about a biological system, develop both agent-based and ODE models, and then evaluate the benefits and drawbacks of each approach."
  },
  {
    "objectID": "posts/delta-notch/index.html#acknowledgement",
    "href": "posts/delta-notch/index.html#acknowledgement",
    "title": "Comparing Models of Delta-Notch Signalling",
    "section": "Acknowledgement",
    "text": "Acknowledgement\nThis material for this post is from a group project for MATH 462/560 (Projects in Mathematical Biology) at the University of British Columbia. You can find the code for the project here and the final report here5."
  },
  {
    "objectID": "posts/delta-notch/index.html#delta-notch-signalling",
    "href": "posts/delta-notch/index.html#delta-notch-signalling",
    "title": "Comparing Models of Delta-Notch Signalling",
    "section": "Delta-Notch Signalling",
    "text": "Delta-Notch Signalling\nInteractions between Delta and Notch molecules play an important role in determining cell fate in a wide variety of plants and animals. Differences in cell fates are responsible for the emergence of patterns (i.e.¬†the stripes of a zebra) and organ development (i.e.¬†the formation of a heart within an embryo). Furthermore, issues with Delta-Notch signalling have been implicated in various cancers.\nSo how does Delta-Notch signalling work?\nNotch is a receptor located on the cell membrane which can bind to a single Delta molecule. Notch receptors always bind to Delta molecules from neighbouring cells1. When a binding event occurs, a single NICD molecule is created inside the cell. Then, the Notch and Delta molecules are removed from the membrane. Within the cell, the NICD molecule does two things:\n\nPromotes the production of new Notch molecules.\nInhibits the production of new Delta molecules.\n\nNow, imagine a cell whose neighbours have a high concentration of Delta molecules. This will cause many binding events, which will create many NICD molecules within the cell. The high concentration of NICD molecules will inhibit the production of Delta molecules. Therefore, the cell will end up with a low concentration of Delta molecules, unlike its neighbours.\nThe opposite effect occurs in a cell whose neighbours have a low concentration of Delta molecules (i.e.¬†the cell will end up with a high concentration of Delta molecules). This is the mechanism that allows the Delta-Notch signalling network to induce cell differentiation. We will use the following vocabulary to describe cell fates for the rest of this post:\n\nThe primary fate occurs when a cell has high Delta and low Notch.\nThe secondary fate occurs when a cell has low Delta and high Notch."
  },
  {
    "objectID": "posts/delta-notch/index.html#computational-model-the-gillespie-algorithm",
    "href": "posts/delta-notch/index.html#computational-model-the-gillespie-algorithm",
    "title": "Comparing Models of Delta-Notch Signalling",
    "section": "Computational Model: The Gillespie Algorithm",
    "text": "Computational Model: The Gillespie Algorithm\nThe Gillespie algorithm is a method used to simulate biochemical systems at the molecular level, taking into account the inherent randomness of reactions. Instead of assuming continuous changes in concentrations (as in ODE models), it treats each reaction as a discrete event that occurs randomly in time.\nHow the Gillespie Algorithm Works\nInitialize the system: Start with an initial number of molecules for each species.\nDetermine reaction propensities: Calculate the likelihood of each reaction occurring at a given moment based on reaction rates and molecule counts.\nGenerate random waiting time: Use probability distributions to determine when the next reaction will occur.\nChoose which reaction occurs: Randomly select a reaction based on its probability.\nUpdate molecule counts: Adjust the number of molecules based on the chosen reaction.\nRepeat: Continue this process until a certain time limit or number of reactions is reached.\nThe Gillespie algorithm allows scientists to capture the randomness of biological systems more accurately than deterministic models. This is particularly useful for studying gene regulation, cellular signaling, and other molecular processes where fluctuations matter."
  },
  {
    "objectID": "posts/delta-notch/index.html#the-gillespie-algorithm",
    "href": "posts/delta-notch/index.html#the-gillespie-algorithm",
    "title": "Comparing Models of Delta-Notch Signalling",
    "section": "The Gillespie Algorithm",
    "text": "The Gillespie Algorithm\nThe Gillespie algorithm is a method used to simulate biochemical systems at the molecular level, taking into account the inherent randomness of reactions. Instead of assuming continuous changes in concentrations (as in ODE models), it treats each reaction as a discrete event that occurs randomly in time.\nHow the Gillespie Algorithm Works\nInitialize the system: Start with an initial number of molecules for each species.\nDetermine reaction propensities: Calculate the likelihood of each reaction occurring at a given moment based on reaction rates and molecule counts.\nGenerate random waiting time: Use probability distributions to determine when the next reaction will occur.\nChoose which reaction occurs: Randomly select a reaction based on its probability.\nUpdate molecule counts: Adjust the number of molecules based on the chosen reaction.\nRepeat: Continue this process until a certain time limit or number of reactions is reached.\nThe Gillespie algorithm allows scientists to capture the randomness of biological systems more accurately than deterministic models. This is particularly useful for studying gene regulation, cellular signaling, and other molecular processes where fluctuations matter."
  },
  {
    "objectID": "posts/delta-notch/index.html#a-mathematical-model",
    "href": "posts/delta-notch/index.html#a-mathematical-model",
    "title": "Comparing Models of Delta-Notch Signalling",
    "section": "A Mathematical Model",
    "text": "A Mathematical Model"
  },
  {
    "objectID": "posts/delta-notch/index.html#a-b",
    "href": "posts/delta-notch/index.html#a-b",
    "title": "Comparing Models of Delta-Notch Signalling",
    "section": "A B",
    "text": "A B"
  },
  {
    "objectID": "posts/delta-notch/index.html#modelling-chemical-reactions",
    "href": "posts/delta-notch/index.html#modelling-chemical-reactions",
    "title": "Comparing Models of Delta-Notch Signalling",
    "section": "Modelling Chemical Reactions",
    "text": "Modelling Chemical Reactions\nIn order to build a mathematical model of the Delta-Notch signalling network, we first need a precise understanding of the chemical reactions that take place within it. Scientists write chemical reactions using arrow notation. For instance, \\(X \\rightarrow Y\\) means ‚Äúan \\(X\\) is converted into a \\(Y\\)‚Äù. We will use the symbol \\(\\emptyset\\) to represent the abscence of molecules. For example, \\(X \\rightarrow \\emptyset\\) means ‚Äúan \\(X\\) decays‚Äù and \\(\\emptyset \\rightarrow X\\) means ‚Äúan \\(X\\) is produced‚Äù. Chemical reactions can also involve multiple molecules. For instance, \\(X + 2Y \\rightarrow W + Z\\) means ‚Äúan \\(X\\) and two \\(Y\\)‚Äôs are converted into a \\(W\\) and a \\(Z\\)‚Äù. All reactions also have a rate, which determines how quickly or slowly they occur2. We‚Äôll talk more about the reaction rates in the section on modelling with ODEs.\nIn our model of the Delta-Notch signalling network, there are six different chemical reactions that can occur within a single cell. These reactions are listed in the table below, where \\(N\\) is a Notch receptor, \\(D\\) is a Delta molecule, and \\(I\\) is a NICD molecule.\n\n\n\n\n\n\n\nReaction\nDescription\n\n\n\n\n\\(N + D_{ext} \\rightarrow I\\)\nA Delta molecule from another cell binds to a Notch receptor, releasing a NICD molecule.\n\n\n\\(N \\rightarrow \\emptyset\\)\nA Notch receptor decays.\n\n\n\\(D \\rightarrow \\emptyset\\)\nA Delta molecule decays.\n\n\n\\(I \\rightarrow \\emptyset\\)\nA NICD molecule decays.\n\n\n\\(\\emptyset \\rightarrow N\\)\nA Notch receptor is produced.\n\n\n\\(\\emptyset \\rightarrow D\\)\nA Delta molecule is produced."
  },
  {
    "objectID": "posts/delta-notch/index.html#footnotes",
    "href": "posts/delta-notch/index.html#footnotes",
    "title": "Comparing Models of Delta-Notch Signalling",
    "section": "Footnotes",
    "text": "Footnotes\n\n\nThis is not entirely true. It is possible for a Delta molecule to bind to a Notch receptor from the same cell, in which case no NICD molecule is produced. This is known as cis-inhibition. There is also a second molecule known as Serrate or Jagged that binds to Notch receptors with different downstream effects. Boareto et al.¬†(2015) develop an ODE model which incorporates both Serrate and cis-inhibition.‚Ü©Ô∏é\nFixed biological constants like reaction rates are known as parameters in a mathematical model. Usually, experimental biologists have come up with estimates of parameters in their research, which we can use as modellers. Since we almost never know the true value of our parameters, it is important to perform a Sensitivity Analysis and Uncertainty Analysis when modelling biological systems.‚Ü©Ô∏é\nIn particular, we assume that the times between reactions are independent and memoryless. Therefore, the inter-reaction times are exponentially distributed.‚Ü©Ô∏é\nSince the inter-reaction times are exponentially distributed, we can use the fact that for a set of independent random variables \\(X_i \\sim \\text{Exp}(\\lambda_i)\\), we have \\(\\text{min}(X_1, \\dots, X_n) \\sim \\text{Exp}\\left(\\sum_{i=1}^{n} \\lambda_i \\right)\\).‚Ü©Ô∏é\nThe report goes into detail about some really fascinating aspects of the model that were too technical to cover here. In particular, we use bifurcation theory to show the existence of high and low notch steady states (Appendix D) and provide a proof that the agent-based model converges in expectation to the differential equation-based model (Appendix B). We also conduct a stability analysis of all three models and find that the agent-based model is more sensitive to changes in the parameter regime than the differential equation-based models.‚Ü©Ô∏é"
  },
  {
    "objectID": "posts/delta-notch/index.html#an-agent-based-model",
    "href": "posts/delta-notch/index.html#an-agent-based-model",
    "title": "Comparing Models of Delta-Notch Signalling",
    "section": "An Agent-Based Model",
    "text": "An Agent-Based Model\nAs you may recall from the introduction, an agent-based model involves simulating individual entities known as agents. For the Delta-Notch signalling network, the agents are Notch, Delta, and NICD molecules, and the chemical reactions above define how they interact with each other. We will use the Gillespie algorithm to simulate interactions between agents while taking into account the inherent randomness of reactions. Here‚Äôs how the Gillespie algorithm works:\nStep 1: Initialize the system by assigning Notch, Delta, and NICD molecules to each cell.\nStep 2: Calculate the probability of each reaction occurring based on the reaction rates and molecule counts3. The probability of a Delta molecule binding to a Notch receptor is proportional to the product of their concentrations. This is due to the Law of Mass Action.\nStep 3: Generate a random waiting time \\(t_i\\) before the next reaction of any type by ‚Äúadding up‚Äù the probabilities determined in Step 24. Increment the current time by \\(t_i\\).\nStep 4: Choose which reaction occurs by randomly selecting one based on its probability.\nStep 5: Adjust the number of molecules based on the chosen reaction.\nStep 6: Continue Steps 2-5 until a certain time limit or number of reactions is reached.\nUsing the Gillespie algorithm to simulate chemical reactions is very accurate, because we can determine the exact state of the system at any moment in time. However, as the number of molecules increases, the frequency of reactions increases drastically. To generate the plot shown in Figure 1, we required \\(\\approx 100\\,000\\) reactions per simulation. And this was for a system with only two cells and \\(\\approx 200\\) molecule of each type. For simulations involving more molecules and/or cells, using an agent-based model would not be computationally feasible.\n\n\n\nFigure 1: Results of ten simulations of the agent-based model on a two-cell domain. Green lines represent the cell which adopted the primary fate, while orange lines represent the cell which adopted the secondary fate. the The mean (solid) and standard deviation (dashed) over all simulations are shown in bold."
  },
  {
    "objectID": "posts/delta-notch/index.html#a-differential-equation",
    "href": "posts/delta-notch/index.html#a-differential-equation",
    "title": "Comparing Models of Delta-Notch Signalling",
    "section": "A Differential Equation",
    "text": "A Differential Equation"
  },
  {
    "objectID": "posts/delta-notch/index.html#modelling-with-differential-equations",
    "href": "posts/delta-notch/index.html#modelling-with-differential-equations",
    "title": "Comparing Models of Delta-Notch Signalling",
    "section": "Modelling with Differential Equations",
    "text": "Modelling with Differential Equations\nA Differential Equation describes how some quantity (like the number of Notch molecules in a cell) changes over time. To use a differential equation, the quantity we are measuring must be continuous. However, the number of molecules in a cell is discrete, so any model that uses differential equations will be an approximation of the agent-based model. Chemistry doesn‚Äôt deal in halves ‚Äì there can never be \\(120.43\\) Notch molecules in a cell. But with if we simply round \\(120.43\\) to the nearest integer, we‚Äôll get a reasonable approximation of the state of the system.\nDifferential equations are written in the form \\(X' = \\dots\\), where \\(X'\\) denotes the change in \\(X\\) per unit of time. If \\(X' &gt; 0\\), then \\(X\\) is increasing, and if \\(X' &lt; 0\\), then \\(X\\) is decreasing. If \\(X' = 0\\), then \\(X\\) is not changing. We call this a steady state. To model the Delta-Notch signalling network, we use three differential equations for Notch (\\(N\\)), Delta (\\(D\\)), and NICD (\\(I\\)). But before we can do this, we need to define some parameters:\n\n\n\n\n\n\n\nParameter\nDescription\n\n\n\n\n\\(k_{T}\\)\nThe rate at which Delta molecules bind to Notch receptors.\n\n\n\\(\\gamma\\)\nThe rate at which Notch and Delta molecules decay.\n\n\n\\(\\gamma_{I}\\)\nThe rate at which NICD molecules decay.\n\n\n\\(f(I)\\)\nThe rate at which Notch receptors are produced. It is an increasing function of NICD since higher concentrations of NICD lead to higher Notch production.\n\n\n\\(g(I)\\)\nThe rate at which Delta molecules are produced. It is a decreasing function of NICD since higher concentrations of NICD lead to lower Delta production.\n\n\n\nUsing these parameters, we get the following system of differential equations:\n\\[\n\\begin{aligned}\n\\frac{dN}{dt} &= \\underbrace{f(I)}_{\\text{(1)}} - \\underbrace{k_{T}ND_{ext}}_{\\text{(2)}} - \\underbrace{\\gamma N}_{\\text{(3)}} \\\\[5pt]\n\\frac{dD}{dt} &= \\underbrace{g(I)}_{\\text{(4)}} - \\underbrace{k_{T}DN_{ext}}_{\\text{(5)}} - \\underbrace{\\gamma D}_{\\text{(6)}} \\\\[5pt]\n\\frac{dI}{dt} &= \\underbrace{k_{T}ND_{ext}}_{\\text{(7)}} - \\underbrace{\\gamma_{I}I}_{\\text{(8)}}\n\\end{aligned}\n\\]\nLets go through each of the numbered terms one by one to get a better idea of whats going on:\n1: \\(f(I)\\) is the rate of Notch production, so it makes a positive contribution to \\(dN/dt\\).\n2: \\(k_{T}ND_{ext}\\) represents the rate of binding events between Delta molecule from another cell and Notch receptors from this cell. Binding events remove the Notch receptor, so this term contributes negatively to \\(dN/dt\\).\n3: \\(\\gamma N\\) is the rate of Notch decay, so it makes a negative contribution to \\(dN/dt\\).\n4: Similar to (1).\n5: Similar to (2), except now a Delta molcule from this cell is binding to a Notch receptor from another cell. This results in the removal of the Delta molecule, so this term is negative.\n6: Similar to (3).\n7: Every time a Delta molecule from another cell binds to a Notch molecule from this cell, a new NICD molecule is produced, so the binding term contributes positively to \\(dI/dt\\).\n8: Similar to (3) and (6), except NICD has a decay rate of \\(\\gamma_{I}\\) instead of \\(\\gamma\\).\nThe differential equation-based model is deterministic, which means that the result of a simulation is determined entirely by the initial state. If both cells start in exactly the same state, then there will be an identical number of Delta-Notch binding events in each cell, and the cells will not differentiate. Therefore, we make a small, random adjustment to the initial state (a perturbation) in order to ensure that cell differentiation occurs.\n\n\n\nFigure 2: Results of ten simulations of the differential equation-based model with random perturbations to the initial condition on a two-cell domain. Green lines represent the cell which adopted the primary fate, while orange lines represent the cell which adopted the secondary fate. The mean (solid) and standard deviation (dashed) over all simulations are shown in bold.\n\n\n\nAdding Randomness to Differential Equations\nFrom Figure 2, we can see that the differential equations produce very ‚Äúsmooth‚Äù simulations compared to the ‚Äújagged‚Äù simulations produced by the agent-based model. Since we know the agent-based model is closer to reality (because it simulates individual reactions), it would be nice if we could include some randomness in the differential equations. We can do this by adding a Wiener Process to each differential equation. By reintroducing randomness into our model, we no longer need to add an initial perturbation, since the noise created by the Wiener Process is sufficient to drive cell differentiation.\n\n\n\nFigure 3: Results of ten simulations of the differential equation-based model added randomness. Green lines represent the cell which adopted the primary fate, while orange lines represent the cell which adopted the secondary fate. The mean (solid) and standard deviation (dashed) over all simulations are shown in bold.\n\n\n\n\nEstimating the Noise Coefficient"
  },
  {
    "objectID": "posts/delta-notch/index.html#i",
    "href": "posts/delta-notch/index.html#i",
    "title": "Comparing Models of Delta-Notch Signalling",
    "section": "I",
    "text": "I"
  },
  {
    "objectID": "posts/delta-notch/index.html#conclusion",
    "href": "posts/delta-notch/index.html#conclusion",
    "title": "Comparing Models of Delta-Notch Signalling",
    "section": "Conclusion",
    "text": "Conclusion\nMathematical models are essential tools for understanding biological systems. While ordinary differential equation models give us a broad view of how molecule concentrations change over time, agent-based models offer a more detailed picture of the inherent randomness in biological processes. Building models of complicated systems often involves a trade-off between accuracy and computational efficiency. In the specific case of the Delta-Notch signalling network, our research shows that a differential equation-based model with added randomness is an elegant solution to this trade-off.\nThis blend of biology, mathematics, and computer science is what makes mathematical biology such an exciting field to me. If you are a UBC student interested in learning more about mathematical biology, I would highly recommend taking MATH 361/462. The differential equations sequence (MATH 215/316) and the probability sequence (MATH 302/303) are also quite useful for mathematical biology.\nThanks for reading!"
  },
  {
    "objectID": "posts/delta-notch/index.html#modelling-with-odes",
    "href": "posts/delta-notch/index.html#modelling-with-odes",
    "title": "Comparing Models of Delta-Notch Signalling",
    "section": "Modelling with ODEs",
    "text": "Modelling with ODEs\nAn Ordinary Differential Equation (ODE) describes how some quantity (like the number of Notch molecules in a cell) changes over time. To use an ODE, the quantity we are measuring must be continuous. However, the number of molecules in a cell is discrete, so any model that uses ODEs will be an approximation of the agent-based model. Chemistry doesn‚Äôt deal in halves ‚Äì there can never be \\(120.43\\) Notch molecules in a cell. But with if we simply round \\(120.43\\) to the nearest integer, we‚Äôll get a reasonable approximation of the state of the system.\nODEs are written in the form \\(X' = f(X)\\), where \\(X'\\) denotes the change in \\(X\\) per unit of time. If \\(X' &gt; 0\\), then \\(X\\) is increasing, and if \\(X' &lt; 0\\), then \\(X\\) is decreasing. If \\(X' = 0\\), then \\(X\\) is not changing. We call this a steady state. To model the Delta-Notch signalling network, we use three ODEs for Notch (\\(N\\)), Delta (\\(D\\)), and NICD (\\(I\\)). But before we can do this, we need to define parameters for each of the six reactions.\n\n\n\n\n\n\n\nParameter\nDescription\n\n\n\n\n\\(k_{T}\\)\nThe rate at which Delta molecules bind to Notch receptors.\n\n\n\\(\\gamma\\)\nThe rate at which Notch and Delta molecules decay.\n\n\n\\(\\gamma_{I}\\)\nThe rate at which NICD molecules decay.\n\n\n\\(f(I)\\)\nThe rate at which Notch receptors are produced. It is an increasing function of NICD since higher concentrations of NICD lead to higher Notch production.\n\n\n\\(g(I)\\)\nThe rate at which Delta molecules are produced. It is a decreasing function of NICD since higher concentrations of NICD lead to lower Delta production.\n\n\n\nUsing these parameters, we get the following system of ODEs:\n\\[\n\\begin{aligned}\n\\frac{dN}{dt} &= \\underbrace{f(I)}_{\\text{(1)}} - \\underbrace{k_{T}ND_{ext}}_{\\text{(2)}} - \\underbrace{\\gamma N}_{\\text{(3)}} \\\\[5pt]\n\\frac{dD}{dt} &= \\underbrace{g(I)}_{\\text{(4)}} - \\underbrace{k_{T}DN_{ext}}_{\\text{(5)}} - \\underbrace{\\gamma D}_{\\text{(6)}} \\\\[5pt]\n\\frac{dI}{dt} &= \\underbrace{k_{T}ND_{ext}}_{\\text{(7)}} - \\underbrace{\\gamma_{I}I}_{\\text{(8)}}\n\\end{aligned}\n\\]\nLets go through each of the numbered terms one by one to get a better idea of whats going on:\n\n\\(f(I)\\) is the rate of Notch production, so it makes a positive contribution to \\(dN/dt\\).\n\\(k_{T}ND_{ext}\\) is the rate at which Delta molecule from another cell bind to Notch receptors from this cell. Binding events remove the Notch receptor, so this term is negative.\n\\(\\gamma N\\) is the rate of Notch decay, so it makes a negative contribution to \\(dN/dt\\).\nSimilar to (1).\nSimilar to (2), except now a Delta molecule from this cell is binding to a Notch receptor from another cell. This results in the removal of the Delta molecule, so this term is negative.\nSimilar to (3).\nEvery time a Delta molecule from another cell binds to a Notch molecule from this cell, a new NICD molecule is produced, so the binding term contributes positively to \\(dI/dt\\).\nSimilar to (3) and (6), except NICD has a decay rate of \\(\\gamma_{I}\\) instead of \\(\\gamma\\).\n\nThe ODE model is deterministic, which means that the result of a simulation is determined entirely by the initial state. If both cells start in exactly the same state, then there will be an identical number of Delta-Notch binding events in each cell, and the cells will not differentiate. Therefore, we make a small, random adjustment to the initial state (a perturbation) in order to ensure that cell differentiation occurs. Simulations of the deterministic ODE model are shown in Figure 2.\n\n\n\nFigure 2: Results of \\(10\\) simulations of the ODE model with random perturbations to the initial condition on a \\(2\\)-cell domain. Green lines represent the cell which adopted the primary fate, while orange lines represent the cell which adopted the secondary fate. The mean (solid) and standard deviation (dashed) over all simulations are shown in bold.\n\n\n\nAdding Randomness\nFrom Figure 2, we can see that the deterministic ODE model produces ‚Äúsmooth‚Äù simulations compared to the ‚Äújagged‚Äù simulations produced by the agent-based model. Since we know the agent-based model is closer to reality (because it simulates individual reactions), it would be nice if we could include some randomness in the deterministic ODE model. We can do this by adding noise via a Wiener Process to each ODE. By reintroducing randomness into our model, we no longer need to add an initial perturbation, since the noise created by the Wiener Process is sufficient to drive cell differentiation. We call this new model the stochastic ODE model.\n\n\n\nFigure 3: Results of \\(10\\) simulations of the stochastic ODE model on a \\(2\\)-cell domain. Green lines represent the cell which adopted the primary fate, while orange lines represent the cell which adopted the secondary fate. The mean (solid) and standard deviation (dashed) over all simulations are shown in bold.\n\n\n\n\nEstimating the Noise Coefficient\nFigure 3 looks really similar to Figure 1, but how can we be sure that we added the right amount of noise? One technique we explored was to use the differentiation time, or the mean length of time it takes for the cell with the primary fate to reach \\(\\approx 0\\) Notch molecules. Higher amounts of noise increase the probability that the two cells become irreversibly different, which reduces the differentiation time. Therefore, by comparing the differentiation times between the stochastic ODE model and agent-based model, we can estimate the noise coefficient that most accurately replicates the real system.\n\n\n\nFigure 4: This plot shows the distribution of differentiation times simulations of the stochastic ODE model with different noise coefficients, as well as the agent-based model. Higher levels of noise result in shorter differentiation times (pink), while lower levels of noise result in longer differentiation times (orange). A noise coefficient of \\(0.02\\) (brown) produces differentiation times most similar to the agent-based model (blue)."
  },
  {
    "objectID": "posts/delta-notch/index.html#the-agent-based-model",
    "href": "posts/delta-notch/index.html#the-agent-based-model",
    "title": "Comparing Models of Delta-Notch Signalling",
    "section": "The Agent-Based Model",
    "text": "The Agent-Based Model\nAs you may recall from the introduction, an agent-based model involves simulating individual entities known as agents. For the Delta-Notch signalling network, the agents are Notch, Delta, and NICD molecules, and the chemical reactions above define how they interact with each other. We will use the Gillespie algorithm to simulate interactions between agents while taking into account the inherent randomness of reactions. Here‚Äôs how the Gillespie algorithm works:\n\nInitialize the system by assigning Notch, Delta, and NICD molecules to each cell.\nCalculate the probability of each reaction occurring based on the reaction rates and molecule counts3. The probability of a Delta molecule binding to a Notch receptor is proportional to the product of their concentrations. This is due to the Law of Mass Action.\nGenerate a random waiting time \\(t_i\\) before the next reaction of any type by ‚Äúadding up‚Äù the probabilities determined in Step 24. Increment the current time by \\(t_i\\).\nChoose which reaction occurs by randomly selecting one based on its probability.\nAdjust the number of molecules based on the chosen reaction.\nContinue Steps 2-5 until a certain time limit or number of reactions is reached.\n\nUsing the Gillespie algorithm to simulate chemical reactions is very accurate, because we can determine the exact state of the system at any moment in time. However, as the number of molecules increases, the frequency of reactions increases drastically. To generate the plot shown in Figure 1, we required \\(\\approx 100\\,000\\) reactions per simulation. And this was for a system with only two cells and \\(\\approx 200\\) molecule of each type. For simulations involving more molecules and/or cells, using an agent-based model would not be computationally feasible.\n\n\n\nFigure 1: Results of \\(10\\) simulations of the agent-based model on a \\(2\\)-cell domain. Green lines represent the cell which adopted the primary fate, while orange lines represent the cell which adopted the secondary fate. the The mean (solid) and standard deviation (dashed) over all simulations are shown in bold."
  }
]