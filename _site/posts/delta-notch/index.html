<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.7.6">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">

<meta name="dcterms.date" content="2025-03-30">

<title>Comparing Models of Delta-Notch Signalling – Home</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1em; /* quarto-specific, see https://github.com/quarto-dev/quarto-cli/issues/4556 */ 
  vertical-align: middle;
}
</style>


<script src="../../site_libs/quarto-nav/quarto-nav.js"></script>
<script src="../../site_libs/quarto-nav/headroom.min.js"></script>
<script src="../../site_libs/clipboard/clipboard.min.js"></script>
<script src="../../site_libs/quarto-search/autocomplete.umd.js"></script>
<script src="../../site_libs/quarto-search/fuse.min.js"></script>
<script src="../../site_libs/quarto-search/quarto-search.js"></script>
<meta name="quarto:offset" content="../../">
<script src="../../site_libs/quarto-html/quarto.js"></script>
<script src="../../site_libs/quarto-html/popper.min.js"></script>
<script src="../../site_libs/quarto-html/tippy.umd.min.js"></script>
<script src="../../site_libs/quarto-html/anchor.min.js"></script>
<link href="../../site_libs/quarto-html/tippy.css" rel="stylesheet">
<link href="../../site_libs/quarto-html/quarto-syntax-highlighting-6c21014d9765ba549c6ebad95917e4d7.css" rel="stylesheet" id="quarto-text-highlighting-styles">
<script src="../../site_libs/bootstrap/bootstrap.min.js"></script>
<link href="../../site_libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="../../site_libs/bootstrap/bootstrap-7804d4aec1bd18fc9d91d728704bbbf6.min.css" rel="stylesheet" append-hash="true" id="quarto-bootstrap" data-mode="light">
<script id="quarto-search-options" type="application/json">{
  "location": "navbar",
  "copy-button": false,
  "collapse-after": 3,
  "panel-placement": "end",
  "type": "overlay",
  "limit": 50,
  "keyboard-shortcut": [
    "f",
    "/",
    "s"
  ],
  "show-item-context": false,
  "language": {
    "search-no-results-text": "No results",
    "search-matching-documents-text": "matching documents",
    "search-copy-link-title": "Copy link to search",
    "search-hide-matches-text": "Hide additional matches",
    "search-more-match-text": "more match in this document",
    "search-more-matches-text": "more matches in this document",
    "search-clear-button-title": "Clear",
    "search-text-placeholder": "",
    "search-detached-cancel-button-title": "Cancel",
    "search-submit-button-title": "Submit",
    "search-label": "Search"
  }
}</script>

  <script src="https://cdnjs.cloudflare.com/polyfill/v3/polyfill.min.js?features=es6"></script>
  <script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml-full.js" type="text/javascript"></script>

<script type="text/javascript">
const typesetMath = (el) => {
  if (window.MathJax) {
    // MathJax Typeset
    window.MathJax.typeset([el]);
  } else if (window.katex) {
    // KaTeX Render
    var mathElements = el.getElementsByClassName("math");
    var macros = [];
    for (var i = 0; i < mathElements.length; i++) {
      var texText = mathElements[i].firstChild;
      if (mathElements[i].tagName == "SPAN") {
        window.katex.render(texText.data, mathElements[i], {
          displayMode: mathElements[i].classList.contains('display'),
          throwOnError: false,
          macros: macros,
          fleqn: false
        });
      }
    }
  }
}
window.Quarto = {
  typesetMath
};
</script>

</head>

<body class="nav-fixed fullcontent">

<div id="quarto-search-results"></div>
  <header id="quarto-header" class="headroom fixed-top quarto-banner">
    <nav class="navbar navbar-expand-lg " data-bs-theme="dark">
      <div class="navbar-container container-fluid">
      <div class="navbar-brand-container mx-auto">
    <a class="navbar-brand" href="../../index.html">
    <span class="navbar-title">Home</span>
    </a>
  </div>
            <div id="quarto-search" class="" title="Search"></div>
          <button class="navbar-toggler" type="button" data-bs-toggle="collapse" data-bs-target="#navbarCollapse" aria-controls="navbarCollapse" role="menu" aria-expanded="false" aria-label="Toggle navigation" onclick="if (window.quartoToggleHeadroom) { window.quartoToggleHeadroom(); }">
  <span class="navbar-toggler-icon"></span>
</button>
          <div class="collapse navbar-collapse" id="navbarCollapse">
            <ul class="navbar-nav navbar-nav-scroll ms-auto">
  <li class="nav-item">
    <a class="nav-link" href="../../assets/resume.pdf"> 
<span class="menu-text">Résumé</span></a>
  </li>  
  <li class="nav-item">
    <a class="nav-link" href="../../blog.html"> 
<span class="menu-text">Blog</span></a>
  </li>  
  <li class="nav-item compact">
    <a class="nav-link" href="https://github.com/rileywheadon"> <i class="bi bi-github" role="img">
</i> 
<span class="menu-text"></span></a>
  </li>  
  <li class="nav-item compact">
    <a class="nav-link" href="https://linkedin.com/in/riley-wheadon-91b639354"> <i class="bi bi-linkedin" role="img">
</i> 
<span class="menu-text"></span></a>
  </li>  
</ul>
          </div> <!-- /navcollapse -->
            <div class="quarto-navbar-tools">
</div>
      </div> <!-- /container-fluid -->
    </nav>
</header>
<!-- content -->
<header id="title-block-header" class="quarto-title-block default page-columns page-full">
  <div class="quarto-title-banner page-columns page-full">
    <div class="quarto-title column-body">
      <h1 class="title">Comparing Models of Delta-Notch Signalling</h1>
                                <div class="quarto-categories">
                <div class="quarto-category">Mathematics</div>
                <div class="quarto-category">Biology</div>
                <div class="quarto-category">Modelling</div>
                <div class="quarto-category">Python</div>
              </div>
                  </div>
  </div>
    
  
  <div class="quarto-title-meta">

      
      <div>
      <div class="quarto-title-meta-heading">Published</div>
      <div class="quarto-title-meta-contents">
        <p class="date">March 30, 2025</p>
      </div>
    </div>
    
      <div>
      <div class="quarto-title-meta-heading">Modified</div>
      <div class="quarto-title-meta-contents">
        <p class="date-modified">March 30, 2025</p>
      </div>
    </div>
      
    </div>
    
  
  </header><div id="quarto-content" class="quarto-container page-columns page-rows-contents page-layout-article page-navbar">
<!-- sidebar -->
<!-- margin-sidebar -->
    
<!-- main -->
<main class="content quarto-banner-title-block" id="quarto-document-content">





<p><em>Mathematical biology</em> is a field of study that uses mathematical models to better understand the natural world. Oftentimes, these models involve simulating the behaviour of individual molecules, cells, or organisms (<em>agents</em>). While highly accurate, these <em>agent-based models</em> can be computationally expensive. Therefore, when the number of agents becomes large, it becomes impractical to track each one individually. Instead, mathematicians use <em>ordinary differential equations</em> (ODEs) to describe the collective behaviour of the entire population. In this post, we’ll learn about a biological system, develop both agent-based and ODE models, and then evaluate the benefits and drawbacks of each approach. Finally, we’ll explore how adding randomness to the ODE model can bridge the gap between the computational efficiency of differential equations and the accuracy of agent-based simulations.</p>
<section id="delta-notch-signalling" class="level2">
<h2 class="anchored" data-anchor-id="delta-notch-signalling">Delta-Notch Signalling</h2>
<p>Interactions between Delta and Notch molecules play an important role in determining cell fate in a wide variety of plants and animals. Differences in cell fates are responsible for the emergence of patterns (i.e.&nbsp;the stripes of a zebra) and organ development (i.e.&nbsp;the formation of a heart within an embryo). Furthermore, issues with Delta-Notch signalling have been implicated in various cancers.</p>
<p>So how does Delta-Notch signalling work?</p>
<p>Notch is a <em>receptor</em> located on the cell membrane which can <em>bind</em> to a single Delta molecule. Notch receptors always bind to Delta molecules from neighbouring cells<a href="#fn1" class="footnote-ref" id="fnref1" role="doc-noteref"><sup>1</sup></a>. When a binding event occurs, a single NICD molecule is created inside the cell. Then, the Notch and Delta molecules are removed from the membrane. Within the cell, the NICD molecule does two things:</p>
<ol type="1">
<li>Promotes the production of new Notch molecules.</li>
<li>Inhibits the production of new Delta molecules.</li>
</ol>
<p>Now, imagine a cell whose neighbours have a <em>high</em> concentration of Delta molecules. This will cause many binding events, which will create many NICD molecules within the cell. The high concentration of NICD molecules will inhibit the production of Delta molecules. Therefore, the cell will end up with a <em>low</em> concentration of Delta molecules, unlike its neighbours.</p>
<p>The opposite effect occurs in a cell whose neighbours have a <em>low</em> concentration of Delta molecules (i.e.&nbsp;the cell will end up with a <em>high</em> concentration of Delta molecules). This is the mechanism that allows the Delta-Notch signalling network to induce cell differentiation. We will use the following vocabulary to describe cell fates for the rest of this post:</p>
<ul>
<li>The <em>primary fate</em> occurs when a cell has <em>high</em> Delta and <em>low</em> Notch.</li>
<li>The <em>secondary fate</em> occurs when a cell has <em>low</em> Delta and <em>high</em> Notch.</li>
</ul>
</section>
<section id="modelling-chemical-reactions" class="level2">
<h2 class="anchored" data-anchor-id="modelling-chemical-reactions">Modelling Chemical Reactions</h2>
<p>In order to build a mathematical model of the Delta-Notch signalling network, we first need a precise understanding of the chemical reactions that take place within it. Scientists write chemical reactions using arrow notation. For instance, <span class="math inline">\(X \rightarrow Y\)</span> means “an <span class="math inline">\(X\)</span> is converted into a <span class="math inline">\(Y\)</span>”. We will use the symbol <span class="math inline">\(\emptyset\)</span> to represent the absence of molecules. For example, <span class="math inline">\(X \rightarrow \emptyset\)</span> means “an <span class="math inline">\(X\)</span> decays” and <span class="math inline">\(\emptyset \rightarrow X\)</span> means “an <span class="math inline">\(X\)</span> is produced”. Chemical reactions can also involve multiple molecules. For instance, <span class="math inline">\(X + 2Y \rightarrow W + Z\)</span> means “an <span class="math inline">\(X\)</span> and two <span class="math inline">\(Y\)</span>’s are converted into a <span class="math inline">\(W\)</span> and a <span class="math inline">\(Z\)</span>”. All reactions also have a rate, which determines how quickly or slowly they occur<a href="#fn2" class="footnote-ref" id="fnref2" role="doc-noteref"><sup>2</sup></a>. We’ll talk more about the reaction rates in the section on modelling with ODEs.</p>
<p>Our model of the Delta-Notch signalling network includes six chemical reactions that can occur within a single cell. These reactions are listed in the table below, where <span class="math inline">\(N\)</span> is a Notch receptor, <span class="math inline">\(D\)</span> is a Delta molecule, and <span class="math inline">\(I\)</span> is a NICD molecule.</p>
<table class="caption-top table">
<colgroup>
<col style="width: 25%">
<col style="width: 75%">
</colgroup>
<thead>
<tr class="header">
<th>Reaction</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><span class="math inline">\(N + D_{ext} \rightarrow I\)</span></td>
<td>A Delta molecule from another cell binds to a Notch receptor, releasing a NICD molecule.</td>
</tr>
<tr class="even">
<td><span class="math inline">\(N \rightarrow \emptyset\)</span></td>
<td>A Notch receptor decays.</td>
</tr>
<tr class="odd">
<td><span class="math inline">\(D \rightarrow \emptyset\)</span></td>
<td>A Delta molecule decays.</td>
</tr>
<tr class="even">
<td><span class="math inline">\(I \rightarrow \emptyset\)</span></td>
<td>A NICD molecule decays.</td>
</tr>
<tr class="odd">
<td><span class="math inline">\(\emptyset \rightarrow N\)</span></td>
<td>A Notch receptor is produced.</td>
</tr>
<tr class="even">
<td><span class="math inline">\(\emptyset \rightarrow D\)</span></td>
<td>A Delta molecule is produced.</td>
</tr>
</tbody>
</table>
</section>
<section id="the-agent-based-model" class="level2">
<h2 class="anchored" data-anchor-id="the-agent-based-model">The Agent-Based Model</h2>
<p>As you may recall from the introduction, an <em>agent-based model</em> involves simulating individual entities known as <em>agents</em>. For the Delta-Notch signalling network, the agents are Notch, Delta, and NICD molecules, and the chemical reactions above define how they interact with each other. We will use the <em>Gillespie algorithm</em> to simulate interactions between agents while taking into account the inherent randomness of reactions. Here’s how the Gillespie algorithm works:</p>
<ol type="1">
<li>Initialize the system by assigning Notch, Delta, and NICD molecules to each cell.</li>
<li>Calculate the probability of each reaction occurring based on the reaction rates and molecule counts<a href="#fn3" class="footnote-ref" id="fnref3" role="doc-noteref"><sup>3</sup></a>. The probability of a Delta molecule binding to a Notch receptor is proportional to the product of their concentrations. This is due to the <a href="https://en.wikipedia.org/wiki/Law_of_mass_action">Law of Mass Action</a>.</li>
<li>Generate a random waiting time <span class="math inline">\(t_i\)</span> before the next reaction <em>of any type</em> by “adding up” the probabilities determined in Step 2<a href="#fn4" class="footnote-ref" id="fnref4" role="doc-noteref"><sup>4</sup></a>. Increment the current time by <span class="math inline">\(t_i\)</span>.</li>
<li>Choose which reaction occurs by randomly selecting one based on its probability.</li>
<li>Adjust the number of molecules based on the chosen reaction.</li>
<li>Continue Steps 2-5 until a certain time limit or number of reactions is reached.</li>
</ol>
<p>Using the Gillespie algorithm to simulate chemical reactions is very accurate, because we can determine the exact state of the system at any moment in time. However, as the number of molecules increases, the frequency of reactions increases drastically. Generating the plot shown in Figure 1, required <span class="math inline">\(\approx 100\,000\)</span> reactions per simulation, highlighting the computational expense of agent-based modelling. And this was for a system with only two cells and <span class="math inline">\(\approx 200\)</span> molecule of each type. For simulations involving more molecules and/or cells, using an agent-based model would not be computationally feasible.</p>
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="agent-based.png" class="img-fluid figure-img"></p>
<figcaption>Figure 1: Results of <span class="math inline">\(10\)</span> simulations of the agent-based model on a <span class="math inline">\(2\)</span>-cell domain. Green lines represent the cell which adopted the primary fate, while orange lines represent the cell which adopted the secondary fate. The mean (solid) and standard deviation (dashed) over all simulations are shown in bold.</figcaption>
</figure>
</div>
</section>
<section id="modelling-with-odes" class="level2">
<h2 class="anchored" data-anchor-id="modelling-with-odes">Modelling with ODEs</h2>
<p>An <em>Ordinary Differential Equation</em> (ODE) describes how some quantity (like the number of Notch molecules in a cell) changes over time. To use an ODE, the quantity we are measuring must be <em>continuous</em>. However, the number of molecules in a cell is <em>discrete</em>, so any model that uses ODEs will be an approximation of the agent-based model. Chemistry doesn’t deal in halves – there can never be <span class="math inline">\(120.43\)</span> Notch molecules in a cell. But if we simply round <span class="math inline">\(120.43\)</span> to the nearest integer, we’ll get a reasonable approximation of the state of the system.</p>
<p>ODEs are written in the form <span class="math inline">\(X' = f(X)\)</span>, where <span class="math inline">\(X'\)</span> denotes the change in <span class="math inline">\(X\)</span> per unit of time. If <span class="math inline">\(X' &gt; 0\)</span>, then <span class="math inline">\(X\)</span> is increasing, and if <span class="math inline">\(X' &lt; 0\)</span>, then <span class="math inline">\(X\)</span> is decreasing. If <span class="math inline">\(X' = 0\)</span>, then <span class="math inline">\(X\)</span> is not changing. We call this a <em>steady state</em>, since the system remains unchanged over time. To model the Delta-Notch signalling network, we use three ODEs for Notch (<span class="math inline">\(N\)</span>), Delta (<span class="math inline">\(D\)</span>), and NICD (<span class="math inline">\(I\)</span>). But before we can do this, we need to define parameters for each of the six reactions.</p>
<table class="caption-top table">
<colgroup>
<col style="width: 15%">
<col style="width: 85%">
</colgroup>
<thead>
<tr class="header">
<th>Parameter</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><span class="math inline">\(k_{T}\)</span></td>
<td>The rate at which Delta molecules bind to Notch receptors.</td>
</tr>
<tr class="even">
<td><span class="math inline">\(\gamma\)</span></td>
<td>The rate at which Notch and Delta molecules decay.</td>
</tr>
<tr class="odd">
<td><span class="math inline">\(\gamma_{I}\)</span></td>
<td>The rate at which NICD molecules decay.</td>
</tr>
<tr class="even">
<td><span class="math inline">\(f(I)\)</span></td>
<td>The rate at which Notch receptors are produced. It is an <em>increasing</em> function of NICD since higher concentrations of NICD lead to higher Notch production.</td>
</tr>
<tr class="odd">
<td><span class="math inline">\(g(I)\)</span></td>
<td>The rate at which Delta molecules are produced. It is a <em>decreasing</em> function of NICD since higher concentrations of NICD lead to lower Delta production.</td>
</tr>
</tbody>
</table>
<p>Using these parameters, we get the <em>deterministic ODE model</em>:</p>
<p><span class="math display">\[
\begin{aligned}
\frac{dN}{dt} &amp;= \underbrace{f(I)}_{\text{(1)}} - \underbrace{k_{T}ND_{ext}}_{\text{(2)}} - \underbrace{\gamma N}_{\text{(3)}} \\[5pt]
\frac{dD}{dt} &amp;= \underbrace{g(I)}_{\text{(4)}} - \underbrace{k_{T}DN_{ext}}_{\text{(5)}} - \underbrace{\gamma D}_{\text{(6)}} \\[5pt]
\frac{dI}{dt} &amp;= \underbrace{k_{T}ND_{ext}}_{\text{(7)}} - \underbrace{\gamma_{I}I}_{\text{(8)}}
\end{aligned}
\]</span></p>
<p>Let’s go through each of the numbered terms one by one to get a better idea of what’s going on:</p>
<ol type="1">
<li><span class="math inline">\(f(I)\)</span> is the rate of Notch production, so it makes a <em>positive</em> contribution to <span class="math inline">\(dN/dt\)</span>.</li>
<li><span class="math inline">\(k_{T}ND_{ext}\)</span> is the rate at which Delta molecule from another cell bind to Notch receptors from this cell. Binding events remove the Notch receptor, so this term is <em>negative</em>.</li>
<li><span class="math inline">\(\gamma N\)</span> is the rate of Notch decay, so it makes a <em>negative</em> contribution to <span class="math inline">\(dN/dt\)</span>.</li>
<li>Similar to (1).</li>
<li>Similar to (2), except now a Delta molecule from this cell is binding to a Notch receptor from another cell. This results in the removal of the Delta molecule, so this term is <em>negative</em>.</li>
<li>Similar to (3).</li>
<li>Every time a Delta molecule from another cell binds to a Notch molecule from this cell, a new NICD molecule is produced, so the binding term contributes <em>positively</em> to <span class="math inline">\(dI/dt\)</span>.</li>
<li>Similar to (3) and (6), except NICD has a decay rate of <span class="math inline">\(\gamma_{I}\)</span> instead of <span class="math inline">\(\gamma\)</span>.</li>
</ol>
<p>The ODE model is <em>deterministic</em>, which means that if the initial state is the same, the simulation will always produce the same outcome. If both cells start in exactly the same state, then there will be an identical number of Delta-Notch binding events in each cell, and the cells will not differentiate. Therefore, we make a small, random adjustment to the initial state (a <em>perturbation</em>) in order to ensure that cell differentiation occurs. Simulations of the deterministic ODE model are shown in Figure 2.</p>
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="deterministic-ode.png" class="img-fluid figure-img"></p>
<figcaption>Figure 2: Results of <span class="math inline">\(10\)</span> simulations of the ODE model with random perturbations to the initial condition on a <span class="math inline">\(2\)</span>-cell domain. Green lines represent the cell which adopted the primary fate, while orange lines represent the cell which adopted the secondary fate. The mean (solid) and standard deviation (dashed) over all simulations are shown in bold.</figcaption>
</figure>
</div>
<section id="adding-randomness" class="level3">
<h3 class="anchored" data-anchor-id="adding-randomness">Adding Randomness</h3>
<p>From Figure 2, we can see that the deterministic ODE model produces “smooth” simulations compared to the “jagged” simulations produced by the agent-based model. Since we know the agent-based model more closely reflects reality (because it simulates individual reactions), incorporating some randomness into the deterministic ODE model would be beneficial. We can do this by adding <em>noise</em> via a <a href="https://en.wikipedia.org/wiki/Wiener_process">Wiener Process</a> to each ODE. By reintroducing randomness into our model, we no longer need to add an initial perturbation, since the noise created by the Wiener Process is sufficient to drive cell differentiation. We call this new model the <em>stochastic ODE model</em>.</p>
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="stochastic-ode.png" class="img-fluid figure-img"></p>
<figcaption>Figure 3: Results of <span class="math inline">\(10\)</span> simulations of the stochastic ODE model on a <span class="math inline">\(2\)</span>-cell domain. Green lines represent the cell which adopted the primary fate, while orange lines represent the cell which adopted the secondary fate. The mean (solid) and standard deviation (dashed) over all simulations are shown in bold.</figcaption>
</figure>
</div>
</section>
<section id="estimating-the-noise-coefficient" class="level3">
<h3 class="anchored" data-anchor-id="estimating-the-noise-coefficient">Estimating the Noise Coefficient</h3>
<p>Figure 3 looks really similar to Figure 1, but how can we be sure that we added the right amount of noise? One technique we explored was to use the <em>differentiation time</em>, or the mean length of time it takes for the cell with the primary fate to reach <span class="math inline">\(\approx 0\)</span> Notch molecules. Higher amounts of noise increase the probability that the two cells become irreversibly different, which reduces the differentiation time. Therefore, by comparing differentiation times in the stochastic ODE model and agent-based model, we can get an accurate estimate of the noise coefficient.</p>
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="noise.png" class="img-fluid figure-img"></p>
<figcaption>Figure 4: This plot shows the distribution of differentiation times simulations of the stochastic ODE model with different noise coefficients, as well as the agent-based model. Higher levels of noise result in shorter differentiation times (pink), while lower levels of noise result in longer differentiation times (orange). A noise coefficient of <span class="math inline">\(0.02\)</span> (brown) produces differentiation times most similar to the agent-based model (blue).</figcaption>
</figure>
</div>
</section>
</section>
<section id="conclusion" class="level2">
<h2 class="anchored" data-anchor-id="conclusion">Conclusion</h2>
<p>Mathematical models are essential tools for understanding biological systems. Ordinary differential equation models give us a broad view of how molecule concentrations change over time, while agent-based models offer a more detailed picture of the inherent randomness in biological processes. Building models of complicated systems often involves a trade-off between accuracy and computational efficiency. In the specific case of the Delta-Notch signalling network, our research shows that a differential equation-based model with added randomness is an elegant solution to this trade-off. These insights could be extended to more complex biological systems where computational efficiency is a limiting factor.</p>
<p>This blend of biology, mathematics, and computer science is what makes mathematical biology such an exciting field to me. If you are a UBC student interested in learning more about mathematical biology, I would highly recommend taking MATH 361/462. The differential equations courses (MATH 215/316) and the probability courses (MATH 302/303) are also quite useful for mathematical biology.</p>
<p>Thanks for reading!</p>
</section>
<section id="acknowledgement" class="level2">
<h2 class="anchored" data-anchor-id="acknowledgement">Acknowledgement</h2>
<p>The material for this post is from a group project for MATH 462/560 (Projects in Mathematical Biology) at the University of British Columbia. You can find the code for the project <a href="https://github.com/rileywheadon/delta-notch">here</a> and the final report <a href="https://github.com/rileywheadon/delta-notch/blob/master/paper/paper.pdf">here</a><a href="#fn5" class="footnote-ref" id="fnref5" role="doc-noteref"><sup>5</sup></a>.</p>


</section>


<div id="quarto-appendix" class="default"><section id="footnotes" class="footnotes footnotes-end-of-document" role="doc-endnotes"><h2 class="anchored quarto-appendix-heading">Footnotes</h2>

<ol>
<li id="fn1"><p>In some cases, a Delta molecule can bind to a Notch receptor from the same cell, preventing NICD production. This is known as <em>cis-inhibition</em>. There is also a second molecule known as Serrate or Jagged that binds to Notch receptors with different downstream effects. <a href="https://cpb-us-e1.wpmucdn.com/blogs.rice.edu/dist/4/3844/files/2015/02/PNAS-2015-Boareto-E402-9.pdf">Boareto et al.&nbsp;(2015)</a> develop an ODE model which incorporates both Serrate and cis-inhibition.<a href="#fnref1" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn2"><p>Fixed biological constants like reaction rates are known as <em>parameters</em> in a mathematical model. Usually, experimental biologists have come up with <em>estimates</em> of parameters in their research, which we can use as modellers. Since we almost never know the true value of our parameters, it is important to perform a <a href="https://en.wikipedia.org/wiki/Sensitivity_analysis">Sensitivity Analysis</a> and <a href="https://en.wikipedia.org/wiki/Uncertainty_analysis">Uncertainty Analysis</a> when modelling biological systems.<a href="#fnref2" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn3"><p>In particular, we assume that the times between reactions are independent and memoryless. Therefore, the inter-reaction times are exponentially distributed.<a href="#fnref3" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn4"><p>Since the inter-reaction times are exponentially distributed, we can use the fact that for a set of independent random variables <span class="math inline">\(X_i \sim \text{Exp}(\lambda_i)\)</span>, we have <span class="math inline">\(\text{min}(X_1, \dots, X_n) \sim \text{Exp}\left(\sum_{i=1}^{n} \lambda_i \right)\)</span>.<a href="#fnref4" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn5"><p>The report provides a detailed analysis of the model, covering advanced topics that were beyond the scope of this post. In particular, we use <a href="https://en.wikipedia.org/wiki/Bifurcation_theory">bifurcation theory</a> to show the existence of high and low notch steady states (Appendix D) and provide a proof that the agent-based model converges in expectation to the differential equation-based model (Appendix B). We also conduct a stability analysis of all three models and find that the agent-based model is more sensitive to changes in the parameter regime than the differential equation-based models.<a href="#fnref5" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
</ol>
</section></div></main> <!-- /main -->
<script id="quarto-html-after-body" type="application/javascript">
window.document.addEventListener("DOMContentLoaded", function (event) {
  const toggleBodyColorMode = (bsSheetEl) => {
    const mode = bsSheetEl.getAttribute("data-mode");
    const bodyEl = window.document.querySelector("body");
    if (mode === "dark") {
      bodyEl.classList.add("quarto-dark");
      bodyEl.classList.remove("quarto-light");
    } else {
      bodyEl.classList.add("quarto-light");
      bodyEl.classList.remove("quarto-dark");
    }
  }
  const toggleBodyColorPrimary = () => {
    const bsSheetEl = window.document.querySelector("link#quarto-bootstrap");
    if (bsSheetEl) {
      toggleBodyColorMode(bsSheetEl);
    }
  }
  toggleBodyColorPrimary();  
  const icon = "";
  const anchorJS = new window.AnchorJS();
  anchorJS.options = {
    placement: 'right',
    icon: icon
  };
  anchorJS.add('.anchored');
  const isCodeAnnotation = (el) => {
    for (const clz of el.classList) {
      if (clz.startsWith('code-annotation-')) {                     
        return true;
      }
    }
    return false;
  }
  const onCopySuccess = function(e) {
    // button target
    const button = e.trigger;
    // don't keep focus
    button.blur();
    // flash "checked"
    button.classList.add('code-copy-button-checked');
    var currentTitle = button.getAttribute("title");
    button.setAttribute("title", "Copied!");
    let tooltip;
    if (window.bootstrap) {
      button.setAttribute("data-bs-toggle", "tooltip");
      button.setAttribute("data-bs-placement", "left");
      button.setAttribute("data-bs-title", "Copied!");
      tooltip = new bootstrap.Tooltip(button, 
        { trigger: "manual", 
          customClass: "code-copy-button-tooltip",
          offset: [0, -8]});
      tooltip.show();    
    }
    setTimeout(function() {
      if (tooltip) {
        tooltip.hide();
        button.removeAttribute("data-bs-title");
        button.removeAttribute("data-bs-toggle");
        button.removeAttribute("data-bs-placement");
      }
      button.setAttribute("title", currentTitle);
      button.classList.remove('code-copy-button-checked');
    }, 1000);
    // clear code selection
    e.clearSelection();
  }
  const getTextToCopy = function(trigger) {
      const codeEl = trigger.previousElementSibling.cloneNode(true);
      for (const childEl of codeEl.children) {
        if (isCodeAnnotation(childEl)) {
          childEl.remove();
        }
      }
      return codeEl.innerText;
  }
  const clipboard = new window.ClipboardJS('.code-copy-button:not([data-in-quarto-modal])', {
    text: getTextToCopy
  });
  clipboard.on('success', onCopySuccess);
  if (window.document.getElementById('quarto-embedded-source-code-modal')) {
    const clipboardModal = new window.ClipboardJS('.code-copy-button[data-in-quarto-modal]', {
      text: getTextToCopy,
      container: window.document.getElementById('quarto-embedded-source-code-modal')
    });
    clipboardModal.on('success', onCopySuccess);
  }
    var localhostRegex = new RegExp(/^(?:http|https):\/\/localhost\:?[0-9]*\//);
    var mailtoRegex = new RegExp(/^mailto:/);
      var filterRegex = new RegExp('/' + window.location.host + '/');
    var isInternal = (href) => {
        return filterRegex.test(href) || localhostRegex.test(href) || mailtoRegex.test(href);
    }
    // Inspect non-navigation links and adorn them if external
 	var links = window.document.querySelectorAll('a[href]:not(.nav-link):not(.navbar-brand):not(.toc-action):not(.sidebar-link):not(.sidebar-item-toggle):not(.pagination-link):not(.no-external):not([aria-hidden]):not(.dropdown-item):not(.quarto-navigation-tool):not(.about-link)');
    for (var i=0; i<links.length; i++) {
      const link = links[i];
      if (!isInternal(link.href)) {
        // undo the damage that might have been done by quarto-nav.js in the case of
        // links that we want to consider external
        if (link.dataset.originalHref !== undefined) {
          link.href = link.dataset.originalHref;
        }
      }
    }
  function tippyHover(el, contentFn, onTriggerFn, onUntriggerFn) {
    const config = {
      allowHTML: true,
      maxWidth: 500,
      delay: 100,
      arrow: false,
      appendTo: function(el) {
          return el.parentElement;
      },
      interactive: true,
      interactiveBorder: 10,
      theme: 'quarto',
      placement: 'bottom-start',
    };
    if (contentFn) {
      config.content = contentFn;
    }
    if (onTriggerFn) {
      config.onTrigger = onTriggerFn;
    }
    if (onUntriggerFn) {
      config.onUntrigger = onUntriggerFn;
    }
    window.tippy(el, config); 
  }
  const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
  for (var i=0; i<noterefs.length; i++) {
    const ref = noterefs[i];
    tippyHover(ref, function() {
      // use id or data attribute instead here
      let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
      try { href = new URL(href).hash; } catch {}
      const id = href.replace(/^#\/?/, "");
      const note = window.document.getElementById(id);
      if (note) {
        return note.innerHTML;
      } else {
        return "";
      }
    });
  }
  const xrefs = window.document.querySelectorAll('a.quarto-xref');
  const processXRef = (id, note) => {
    // Strip column container classes
    const stripColumnClz = (el) => {
      el.classList.remove("page-full", "page-columns");
      if (el.children) {
        for (const child of el.children) {
          stripColumnClz(child);
        }
      }
    }
    stripColumnClz(note)
    if (id === null || id.startsWith('sec-')) {
      // Special case sections, only their first couple elements
      const container = document.createElement("div");
      if (note.children && note.children.length > 2) {
        container.appendChild(note.children[0].cloneNode(true));
        for (let i = 1; i < note.children.length; i++) {
          const child = note.children[i];
          if (child.tagName === "P" && child.innerText === "") {
            continue;
          } else {
            container.appendChild(child.cloneNode(true));
            break;
          }
        }
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(container);
        }
        return container.innerHTML
      } else {
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(note);
        }
        return note.innerHTML;
      }
    } else {
      // Remove any anchor links if they are present
      const anchorLink = note.querySelector('a.anchorjs-link');
      if (anchorLink) {
        anchorLink.remove();
      }
      if (window.Quarto?.typesetMath) {
        window.Quarto.typesetMath(note);
      }
      if (note.classList.contains("callout")) {
        return note.outerHTML;
      } else {
        return note.innerHTML;
      }
    }
  }
  for (var i=0; i<xrefs.length; i++) {
    const xref = xrefs[i];
    tippyHover(xref, undefined, function(instance) {
      instance.disable();
      let url = xref.getAttribute('href');
      let hash = undefined; 
      if (url.startsWith('#')) {
        hash = url;
      } else {
        try { hash = new URL(url).hash; } catch {}
      }
      if (hash) {
        const id = hash.replace(/^#\/?/, "");
        const note = window.document.getElementById(id);
        if (note !== null) {
          try {
            const html = processXRef(id, note.cloneNode(true));
            instance.setContent(html);
          } finally {
            instance.enable();
            instance.show();
          }
        } else {
          // See if we can fetch this
          fetch(url.split('#')[0])
          .then(res => res.text())
          .then(html => {
            const parser = new DOMParser();
            const htmlDoc = parser.parseFromString(html, "text/html");
            const note = htmlDoc.getElementById(id);
            if (note !== null) {
              const html = processXRef(id, note);
              instance.setContent(html);
            } 
          }).finally(() => {
            instance.enable();
            instance.show();
          });
        }
      } else {
        // See if we can fetch a full url (with no hash to target)
        // This is a special case and we should probably do some content thinning / targeting
        fetch(url)
        .then(res => res.text())
        .then(html => {
          const parser = new DOMParser();
          const htmlDoc = parser.parseFromString(html, "text/html");
          const note = htmlDoc.querySelector('main.content');
          if (note !== null) {
            // This should only happen for chapter cross references
            // (since there is no id in the URL)
            // remove the first header
            if (note.children.length > 0 && note.children[0].tagName === "HEADER") {
              note.children[0].remove();
            }
            const html = processXRef(null, note);
            instance.setContent(html);
          } 
        }).finally(() => {
          instance.enable();
          instance.show();
        });
      }
    }, function(instance) {
    });
  }
      let selectedAnnoteEl;
      const selectorForAnnotation = ( cell, annotation) => {
        let cellAttr = 'data-code-cell="' + cell + '"';
        let lineAttr = 'data-code-annotation="' +  annotation + '"';
        const selector = 'span[' + cellAttr + '][' + lineAttr + ']';
        return selector;
      }
      const selectCodeLines = (annoteEl) => {
        const doc = window.document;
        const targetCell = annoteEl.getAttribute("data-target-cell");
        const targetAnnotation = annoteEl.getAttribute("data-target-annotation");
        const annoteSpan = window.document.querySelector(selectorForAnnotation(targetCell, targetAnnotation));
        const lines = annoteSpan.getAttribute("data-code-lines").split(",");
        const lineIds = lines.map((line) => {
          return targetCell + "-" + line;
        })
        let top = null;
        let height = null;
        let parent = null;
        if (lineIds.length > 0) {
            //compute the position of the single el (top and bottom and make a div)
            const el = window.document.getElementById(lineIds[0]);
            top = el.offsetTop;
            height = el.offsetHeight;
            parent = el.parentElement.parentElement;
          if (lineIds.length > 1) {
            const lastEl = window.document.getElementById(lineIds[lineIds.length - 1]);
            const bottom = lastEl.offsetTop + lastEl.offsetHeight;
            height = bottom - top;
          }
          if (top !== null && height !== null && parent !== null) {
            // cook up a div (if necessary) and position it 
            let div = window.document.getElementById("code-annotation-line-highlight");
            if (div === null) {
              div = window.document.createElement("div");
              div.setAttribute("id", "code-annotation-line-highlight");
              div.style.position = 'absolute';
              parent.appendChild(div);
            }
            div.style.top = top - 2 + "px";
            div.style.height = height + 4 + "px";
            div.style.left = 0;
            let gutterDiv = window.document.getElementById("code-annotation-line-highlight-gutter");
            if (gutterDiv === null) {
              gutterDiv = window.document.createElement("div");
              gutterDiv.setAttribute("id", "code-annotation-line-highlight-gutter");
              gutterDiv.style.position = 'absolute';
              const codeCell = window.document.getElementById(targetCell);
              const gutter = codeCell.querySelector('.code-annotation-gutter');
              gutter.appendChild(gutterDiv);
            }
            gutterDiv.style.top = top - 2 + "px";
            gutterDiv.style.height = height + 4 + "px";
          }
          selectedAnnoteEl = annoteEl;
        }
      };
      const unselectCodeLines = () => {
        const elementsIds = ["code-annotation-line-highlight", "code-annotation-line-highlight-gutter"];
        elementsIds.forEach((elId) => {
          const div = window.document.getElementById(elId);
          if (div) {
            div.remove();
          }
        });
        selectedAnnoteEl = undefined;
      };
        // Handle positioning of the toggle
    window.addEventListener(
      "resize",
      throttle(() => {
        elRect = undefined;
        if (selectedAnnoteEl) {
          selectCodeLines(selectedAnnoteEl);
        }
      }, 10)
    );
    function throttle(fn, ms) {
    let throttle = false;
    let timer;
      return (...args) => {
        if(!throttle) { // first call gets through
            fn.apply(this, args);
            throttle = true;
        } else { // all the others get throttled
            if(timer) clearTimeout(timer); // cancel #2
            timer = setTimeout(() => {
              fn.apply(this, args);
              timer = throttle = false;
            }, ms);
        }
      };
    }
      // Attach click handler to the DT
      const annoteDls = window.document.querySelectorAll('dt[data-target-cell]');
      for (const annoteDlNode of annoteDls) {
        annoteDlNode.addEventListener('click', (event) => {
          const clickedEl = event.target;
          if (clickedEl !== selectedAnnoteEl) {
            unselectCodeLines();
            const activeEl = window.document.querySelector('dt[data-target-cell].code-annotation-active');
            if (activeEl) {
              activeEl.classList.remove('code-annotation-active');
            }
            selectCodeLines(clickedEl);
            clickedEl.classList.add('code-annotation-active');
          } else {
            // Unselect the line
            unselectCodeLines();
            clickedEl.classList.remove('code-annotation-active');
          }
        });
      }
  const findCites = (el) => {
    const parentEl = el.parentElement;
    if (parentEl) {
      const cites = parentEl.dataset.cites;
      if (cites) {
        return {
          el,
          cites: cites.split(' ')
        };
      } else {
        return findCites(el.parentElement)
      }
    } else {
      return undefined;
    }
  };
  var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
  for (var i=0; i<bibliorefs.length; i++) {
    const ref = bibliorefs[i];
    const citeInfo = findCites(ref);
    if (citeInfo) {
      tippyHover(citeInfo.el, function() {
        var popup = window.document.createElement('div');
        citeInfo.cites.forEach(function(cite) {
          var citeDiv = window.document.createElement('div');
          citeDiv.classList.add('hanging-indent');
          citeDiv.classList.add('csl-entry');
          var biblioDiv = window.document.getElementById('ref-' + cite);
          if (biblioDiv) {
            citeDiv.innerHTML = biblioDiv.innerHTML;
          }
          popup.appendChild(citeDiv);
        });
        return popup.innerHTML;
      });
    }
  }
});
</script>
</div> <!-- /content -->




</body></html>